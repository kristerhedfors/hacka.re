<!DOCTYPE html>
<html>
<head>
    <title>Test RAG 200 Token Chunks</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        .test-result { margin: 10px 0; padding: 10px; border: 1px solid #ccc; }
        .success { background: #d4edda; }
        .error { background: #f8d7da; }
        .info { background: #d1ecf1; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
    </style>
</head>
<body>
    <h1>RAG 200 Token Chunks Test</h1>
    <div>
        <button onclick="testPrecachedEmbeddings()">Test Precached Embeddings</button>
        <button onclick="testChunkPattern()">Test Chunk Pattern Display</button>
        <button onclick="simulateSearch()">Simulate RAG Search</button>
    </div>
    <div id="results"></div>

    <script>
        const resultsDiv = document.getElementById('results');

        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.textContent = message;
            resultsDiv.appendChild(div);
            console.log(message);
        }

        async function testPrecachedEmbeddings() {
            resultsDiv.innerHTML = '';
            log('Testing precached embeddings...');
            
            // Check if precached embeddings exist
            if (window.precachedEmbeddings) {
                log('✓ Precached embeddings loaded', 'success');
                
                // Check document structure
                const docs = window.precachedEmbeddings.documents;
                if (docs && docs.length === 3) {
                    log(`✓ Found ${docs.length} documents`, 'success');
                    
                    docs.forEach(doc => {
                        const chunkCount = doc.vectors.length;
                        const avgTokens = 200; // Our configured chunk size
                        log(`Document ${doc.documentId.toUpperCase()}: ${chunkCount} chunks @ ~${avgTokens} tokens each`, 'info');
                        
                        // Verify chunk size
                        if (chunkCount === 150) {
                            log(`✓ ${doc.documentId.toUpperCase()} has expected 150 chunks`, 'success');
                        } else {
                            log(`⚠ ${doc.documentId.toUpperCase()} has ${chunkCount} chunks (expected 150)`, 'error');
                        }
                        
                        // Check first chunk metadata
                        if (doc.vectors[0]) {
                            const firstChunk = doc.vectors[0];
                            log(`  First chunk ID: ${firstChunk.id}`, 'info');
                            log(`  Chunk size: ${firstChunk.metadata.chunkSize} characters`, 'info');
                        }
                    });
                } else {
                    log('✗ Unexpected number of documents', 'error');
                }
                
                // Check config
                if (window.precachedEmbeddings.config) {
                    const config = window.precachedEmbeddings.config;
                    log(`Configuration: chunkSize=${config.chunkSize}, chunkOverlap=${config.chunkOverlap}`, 'info');
                }
            } else {
                log('✗ Precached embeddings not loaded', 'error');
                log('Make sure to refresh the page and wait for embeddings to load', 'info');
            }
        }

        function testChunkPattern() {
            resultsDiv.innerHTML = '';
            log('Testing chunk pattern formatting...');
            
            // Test the formatChunkPattern function
            function formatChunkPattern(chunks) {
                if (!chunks || chunks.length === 0) return 'none';
                
                const ranges = [];
                let start = chunks[0];
                let end = chunks[0];
                
                for (let i = 1; i <= chunks.length; i++) {
                    if (i < chunks.length && chunks[i] === end + 1) {
                        end = chunks[i];
                    } else {
                        if (start === end) {
                            ranges.push(start.toString());
                        } else if (end === start + 1) {
                            ranges.push(`${start}, ${end}`);
                        } else {
                            ranges.push(`${start}-${end}`);
                        }
                        
                        if (i < chunks.length) {
                            start = chunks[i];
                            end = chunks[i];
                        }
                    }
                }
                
                return ranges.join(', ');
            }
            
            // Test cases
            const testCases = [
                { chunks: [1, 4, 7, 8, 9, 12, 13, 14, 15, 18], expected: '1, 4, 7-9, 12-15, 18' },
                { chunks: [0, 1, 2, 5, 10], expected: '0-2, 5, 10' },
                { chunks: [3], expected: '3' },
                { chunks: [1, 2], expected: '1, 2' },
                { chunks: [1, 3, 5, 7, 9], expected: '1, 3, 5, 7, 9' },
                { chunks: [], expected: 'none' }
            ];
            
            testCases.forEach((test, i) => {
                const result = formatChunkPattern(test.chunks);
                if (result === test.expected) {
                    log(`✓ Test ${i+1}: ${JSON.stringify(test.chunks)} → "${result}"`, 'success');
                } else {
                    log(`✗ Test ${i+1}: Expected "${test.expected}", got "${result}"`, 'error');
                }
            });
        }

        async function simulateSearch() {
            resultsDiv.innerHTML = '';
            log('Simulating RAG search with debug output...');
            
            // Check if debug service is available
            if (!window.DebugService) {
                log('⚠ Debug service not available. Enable debug mode first.', 'error');
                return;
            }
            
            // Enable RAG debug logging
            window.DebugService.enableCategory('rag');
            log('✓ RAG debug logging enabled', 'success');
            
            // Check if VectorRAGService is available
            if (!window.VectorRAGService) {
                log('✗ VectorRAGService not available', 'error');
                return;
            }
            
            log('Searching for "AI safety requirements"...', 'info');
            
            // Mock search to demonstrate chunk pattern output
            const mockResults = [
                { source: 'eu_documents', documentId: 'aia', vectorId: 'aia_chunk_5' },
                { source: 'eu_documents', documentId: 'aia', vectorId: 'aia_chunk_8' },
                { source: 'eu_documents', documentId: 'aia', vectorId: 'aia_chunk_12' },
                { source: 'eu_documents', documentId: 'aia', vectorId: 'aia_chunk_13' },
                { source: 'eu_documents', documentId: 'aia', vectorId: 'aia_chunk_14' },
                { source: 'eu_documents', documentId: 'cra', vectorId: 'cra_chunk_2' },
                { source: 'eu_documents', documentId: 'cra', vectorId: 'cra_chunk_45' },
                { source: 'eu_documents', documentId: 'cra', vectorId: 'cra_chunk_46' },
                { source: 'eu_documents', documentId: 'dora', vectorId: 'dora_chunk_10' },
                { source: 'eu_documents', documentId: 'dora', vectorId: 'dora_chunk_25' },
                { source: 'eu_documents', documentId: 'dora', vectorId: 'dora_chunk_26' },
                { source: 'eu_documents', documentId: 'dora', vectorId: 'dora_chunk_27' }
            ];
            
            // Process results to show chunk patterns
            const chunksByDoc = {};
            mockResults.forEach(result => {
                if (result.source === 'eu_documents') {
                    const docId = result.documentId;
                    if (!chunksByDoc[docId]) {
                        chunksByDoc[docId] = [];
                    }
                    const match = result.vectorId?.match(/_chunk_(\d+)$/);
                    if (match) {
                        chunksByDoc[docId].push(parseInt(match[1]));
                    }
                }
            });
            
            // Format and display patterns
            Object.keys(chunksByDoc).forEach(docId => {
                const chunks = chunksByDoc[docId].sort((a, b) => a - b);
                const pattern = formatChunkPattern(chunks);
                log(`EU Document ${docId.toUpperCase()} chunks: ${pattern}`, 'success');
            });
            
            log('Check browser console for full debug output', 'info');
        }

        function formatChunkPattern(chunks) {
            if (!chunks || chunks.length === 0) return 'none';
            
            const ranges = [];
            let start = chunks[0];
            let end = chunks[0];
            
            for (let i = 1; i <= chunks.length; i++) {
                if (i < chunks.length && chunks[i] === end + 1) {
                    end = chunks[i];
                } else {
                    if (start === end) {
                        ranges.push(start.toString());
                    } else if (end === start + 1) {
                        ranges.push(`${start}, ${end}`);
                    } else {
                        ranges.push(`${start}-${end}`);
                    }
                    
                    if (i < chunks.length) {
                        start = chunks[i];
                        end = chunks[i];
                    }
                }
            }
            
            return ranges.join(', ');
        }
    </script>
</body>
</html>