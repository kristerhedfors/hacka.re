<!DOCTYPE html>
<html>
<head>
    <title>Test JavaScript API Auth Functions</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .result { background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 5px; }
        .success { background: #d4edda; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; border: 1px solid #f5c6cb; }
        button { padding: 10px 20px; margin: 5px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }
        button:hover { background: #0056b3; }
        pre { background: #f8f9fa; padding: 10px; border-radius: 3px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>üß™ JavaScript API Auth Functions Test</h1>
    <p>Testing the authenticated API client functions for hacka.re tool calling</p>
    
    <div>
        <button onclick="testGenerateSecret()">üîë Generate Shared Secret</button>
        <button onclick="testHMACSignature()">üîê Test HMAC Signature</button>
        <button onclick="testMockAPICall()">üì° Test Mock API Call</button>
        <button onclick="testAttackDemo()">üõ°Ô∏è Demo Attack Prevention</button>
    </div>
    
    <div id="results"></div>
    
    <!-- TweetNaCl for cryptography (same as hacka.re) -->
    <script src="lib/tweetnacl/nacl-fast.min.js"></script>
    <script src="lib/tweetnacl/nacl-util.min.js"></script>
    <script src="js/default-functions/api-auth-client.js"></script>
    <script>
        function logResult(title, result, isSuccess = true) {
            const resultsDiv = document.getElementById('results');
            const div = document.createElement('div');
            div.className = `result ${isSuccess ? 'success' : 'error'}`;
            div.innerHTML = `
                <h3>${title}</h3>
                <pre>${JSON.stringify(result, null, 2)}</pre>
            `;
            resultsDiv.appendChild(div);
        }
        
        function testGenerateSecret() {
            try {
                const result = generateSharedSecret();
                logResult('üîë Generate Shared Secret', result, result.success);
            } catch (error) {
                logResult('üîë Generate Shared Secret', { error: error.message }, false);
            }
        }
        
        function testHMACSignature() {
            try {
                // Generate a test secret first
                const secretResult = generateSharedSecret();
                if (!secretResult.success) {
                    throw new Error('Failed to generate secret');
                }
                
                const testBody = JSON.stringify({ test: "data", timestamp: Date.now() });
                const signature = generateHMACSignature(
                    testBody,
                    secretResult.sharedSecret,
                    "POST",
                    "/api/test",
                    { param1: "value1", param2: "value2" },
                    { "content-type": "application/json", "user-agent": "test-client" }
                );
                
                logResult('üîê HMAC Signature Generation', {
                    secret: secretResult.sharedSecret.substring(0, 16) + '...',
                    signature: signature,
                    testBody: testBody
                }, signature.success);
            } catch (error) {
                logResult('üîê HMAC Signature Generation', { error: error.message }, false);
            }
        }
        
        async function testMockAPICall() {
            try {
                // Mock a local "API" call to test the structure
                const secretResult = await generateSharedSecret();
                if (!secretResult.success) {
                    throw new Error('Failed to generate secret');
                }
                
                // This will fail because there's no actual API, but we can test the structure
                const result = await makeAuthenticatedHMACCall(
                    "http://localhost:8002/api/protected",  // Test server from auth_examples
                    secretResult.sharedSecret,
                    {
                        method: "POST",
                        body: JSON.stringify({ test: "data from JS client" }),
                        queryParams: { source: "javascript", test: "true" },
                        headers: { "X-Client": "hacka.re-test" }
                    }
                );
                
                logResult('üì° Mock API Call Test', {
                    ...result,
                    note: "This tests the request structure - server may not be running"
                }, true); // Show as success even if server isn't running
                
            } catch (error) {
                logResult('üì° Mock API Call Test', { 
                    error: error.message,
                    note: "This is expected if test server is not running"
                }, false);
            }
        }
        
        function testAttackDemo() {
            try {
                const secretResult = generateSharedSecret();
                if (!secretResult.success) {
                    throw new Error('Failed to generate secret');
                }
                
                // Generate two signatures with different parameters
                const originalBody = JSON.stringify({ action: "read", user: "123" });
                const originalQuery = { user_id: "123", action: "read" };
                
                const originalSig = generateHMACSignature(
                    originalBody,
                    secretResult.sharedSecret,
                    "POST",
                    "/api/user",
                    originalQuery
                );
                
                // Now try to verify with tampered parameters
                const tamperedQuery = { user_id: "456", action: "delete" };
                const tamperedSig = generateHMACSignature(
                    originalBody,
                    secretResult.sharedSecret,
                    "POST", 
                    "/api/user",
                    tamperedQuery
                );
                
                logResult('üõ°Ô∏è Attack Prevention Demo', {
                    originalRequest: {
                        queryParams: originalQuery,
                        signature: originalSig.signature?.substring(0, 16) + '...',
                        canonical: originalSig.canonical
                    },
                    tamperedRequest: {
                        queryParams: tamperedQuery,
                        signature: tamperedSig.signature?.substring(0, 16) + '...',
                        canonical: tamperedSig.canonical
                    },
                    securityAnalysis: {
                        signaturesAreDifferent: originalSig.signature !== tamperedSig.signature,
                        tamperingDetected: originalSig.signature !== tamperedSig.signature,
                        protectionWorking: "‚úÖ Query parameter tampering produces different signatures"
                    }
                }, true);
                
            } catch (error) {
                logResult('üõ°Ô∏è Attack Prevention Demo', { error: error.message }, false);
            }
        }
        
        // Show initial info
        logResult('‚ÑπÔ∏è JavaScript API Auth Functions Loaded', {
            availableFunctions: [
                'generateSharedSecret()',
                'generateHMACSignature()',
                'makeAuthenticatedHMACCall()',
                'testAPIAuthentication()',
                'makeSecureQueryCall()',
                'demonstrateAttackPrevention()',
                'makeBatchAuthenticatedCalls()'
            ],
            readyForToolCalling: true,
            cryptoAPI: 'TweetNaCl (libsodium-compatible)',
            compatibility: 'Works with libsodium servers'
        }, true);
    </script>
</body>
</html>