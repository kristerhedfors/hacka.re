======================================
üöÄ FEATURE TESTS STARTING
======================================

üìÅ TEST ARTIFACTS WILL BE STORED IN:
  üì∏ Screenshots: /Users/user/dev/hacka.re/_tests/playwright/screenshots/
  üìù Metadata: /Users/user/dev/hacka.re/_tests/playwright/screenshots_data/
  üñ•Ô∏è Console logs: /Users/user/dev/hacka.re/_tests/playwright/console_logs/
  üìä Test output: /Users/user/dev/hacka.re/_tests/playwright/run_feature_tests.out

üí° TIP: Run ./show_test_artifacts.sh to see all artifacts
======================================

Starting HTTP server for tests...
===== Starting HTTP Server for hacka.re Tests =====
Port: 8000
Project Root: /Users/user/dev/hacka.re
==================================================
Checking for existing HTTP server processes on port 8000...
No existing processes found on port 8000.
Changing to project root directory: /Users/user/dev/hacka.re
Starting Python HTTP server on port 8000...
Server started successfully with PID: 28587
Server is now running at http://localhost:8000
Server PID saved to: /Users/user/dev/hacka.re/_tests/playwright/server_pid.txt
==================================================
Server is ready. You can now run your tests.
To stop the server, run: kill -9 $(cat /Users/user/dev/hacka.re/_tests/playwright/server_pid.txt)
==================================================
Running Advanced Feature tests with chromium browser...
Test filter: not (test_page or test_api or test_chat or test_welcome_modal) and (test_function_modal or test_function_icons or test_sharing or test_default_prompts or test_themes or test_clear_chat or test_model_selection or test_copy_chat or test_button_tooltips or test_function_library or test_context_window or test_function_copy or test_function_deletion or test_function_editing or test_function_group or test_function_parsing or test_function_tooltip or test_deterministic_crypto or test_clear_namespace or test_system_prompt or test_token_counter or test_input_field or test_logo_tooltip or test_modals or test_debug_mode or test_model_context_window or test_owasp_prompt_bug or test_prompt_order_and_function_library_prompt or test_rag_modal or test_rag_indexing or test_rag_search or test_rag_bundles or test_rag_integration)

============================= test session starts ==============================
platform darwin -- Python 3.13.3, pytest-8.3.5, pluggy-1.5.0 -- /Users/user/dev/hacka.re/_tests/playwright/.venv/bin/python
cachedir: .pytest_cache
rootdir: /Users/user/dev/hacka.re/_tests/playwright
configfile: pytest.ini
testpaths: .
plugins: playwright-0.7.0, base-url-2.1.0
collecting ... collected 918 items / 726 deselected / 192 selected

test_button_tooltips.py::test_button_tooltips[chromium0] PASSED          [  0%]
test_clear_chat.py::test_clear_chat_button_exists[chromium0] PASSED      [  1%]
test_clear_chat.py::test_clear_chat_confirmation_dialog[chromium0] PASSED [  1%]
test_clear_namespace_settings.py::test_clear_namespace_settings[chromium0] PASSED [  2%]
test_context_window_scaling.py::test_context_window_scaling[chromium0] FAILED [  2%]
test_copy_chat.py::test_copy_chat_button_exists[chromium0] PASSED        [  3%]
test_copy_chat.py::test_copy_chat_functionality[chromium0] PASSED        [  3%]
test_copy_chat.py::test_copy_chat_button_tooltip[chromium0] PASSED       [  4%]
test_debug_mode.py::test_debug_mode_checkbox_exists[chromium0] FAILED    [  4%]
test_debug_mode.py::test_debug_mode_toggle[chromium0] PASSED             [  5%]
test_default_prompts.py::test_default_prompts_section_exists[chromium0] PASSED [  5%]
test_default_prompts.py::test_default_prompts_expand_collapse[chromium0] PASSED [  6%]
test_default_prompts.py::test_default_prompts_content[chromium0] FAILED  [  6%]
test_default_prompts.py::test_default_prompts_selection[chromium0] FAILED [  7%]
test_default_prompts.py::test_default_prompts_info_button[chromium0] PASSED [  7%]
test_default_prompts.py::test_default_prompts_name_click[chromium0] PASSED [  8%]
test_function_copy_buttons.py::test_function_copy_buttons_exist[chromium0] PASSED [  8%]
test_function_copy_buttons.py::test_function_copy_functionality[chromium0] PASSED [  9%]
test_function_deletion.py::test_function_deletion_removes_entire_bundle[chromium0] PASSED [  9%]
test_function_deletion.py::test_multiple_function_collections[chromium0] PASSED [ 10%]
test_function_editing.py::test_function_editing[chromium0] PASSED        [ 10%]
test_function_group_colors.py::test_function_collection_colors[chromium0] FAILED [ 11%]
test_function_icons.py::test_function_calling_icons[chromium0] FAILED    [ 11%]
test_function_icons.py::test_multiple_function_calls_colors[chromium0] FAILED [ 12%]
test_function_library_multi.py::test_function_library_multi[chromium0] FAILED [ 13%]
test_function_library_sharing.py::test_function_library_sharing[chromium0] FAILED [ 13%]
test_function_modal.py::test_function_modal_basic[chromium0] PASSED      [ 14%]
test_function_modal.py::test_function_modal_elements[chromium0] PASSED   [ 14%]
test_function_parsing_logic.py::test_all_functions_callable_by_default[chromium0] FAILED [ 15%]
test_function_parsing_logic.py::test_only_tagged_functions_callable[chromium0] FAILED [ 15%]
test_function_parsing_logic.py::test_tool_tag_works[chromium0] FAILED    [ 16%]
test_function_parsing_logic.py::test_single_line_comment_tags[chromium0] FAILED [ 16%]
test_function_parsing_logic.py::test_mixed_tag_types[chromium0] FAILED   [ 17%]
test_function_tooltip.py::test_function_modal_basic[chromium0] PASSED    [ 17%]
test_function_tooltip.py::test_function_modal_elements[chromium0] PASSED [ 18%]
test_input_field_scroll.py::test_input_field_scroll_behavior[chromium0] FAILED [ 18%]
test_input_field_scroll.py::test_input_field_scroll_safari_emulation[chromium0] FAILED [ 19%]
test_logo_tooltip.py::test_heart_logo_tooltip[chromium0] FAILED          [ 19%]
test_modals.py::test_settings_modal[chromium0] PASSED                    [ 20%]
test_modals.py::test_prompts_modal[chromium0] PASSED                     [ 20%]
test_modals.py::test_share_modal[chromium0] PASSED                       [ 21%]
test_model_context_window.py::test_model_context_window_display[chromium0] SKIPPED [ 21%]
test_model_selection_context_window.py::test_context_window_updates_on_model_selection[chromium0] PASSED [ 22%]
test_model_selection_o4_mini.py::test_o4_mini_context_window_display[chromium0] FAILED [ 22%]
test_models_context_simple.py::test_context_window_display[chromium0] FAILED [ 23%]
test_prompt_order_and_function_library_prompt.py::test_user_prompts_before_default_prompts[chromium0] PASSED [ 23%]
test_prompt_order_and_function_library_prompt.py::test_function_library_default_prompt[chromium0] FAILED [ 24%]
test_rag_bundles.py::test_rag_user_bundles_ui_elements[chromium0] FAILED [ 25%]
test_rag_bundles.py::test_rag_bundle_validation_algorithm[chromium0] PASSED [ 25%]
test_rag_bundles.py::test_rag_bundle_storage_operations[chromium0] PASSED [ 26%]
test_rag_bundles.py::test_rag_bundle_display_elements[chromium0] PASSED  [ 26%]
test_rag_bundles.py::test_rag_bundle_file_input_creation[chromium0] PASSED [ 27%]
test_rag_bundles.py::test_rag_bundle_load_button_interaction[chromium0] FAILED [ 27%]
test_rag_bundles.py::test_rag_bundle_removal_confirmation[chromium0] PASSED [ 28%]
test_rag_bundles.py::test_rag_bundle_statistics_accuracy[chromium0] PASSED [ 28%]
test_rag_indexing.py::test_rag_embedding_generation_ui[chromium0] FAILED [ 29%]
test_rag_indexing.py::test_rag_embedding_generation_process[chromium0] FAILED [ 29%]
test_rag_indexing.py::test_rag_embedding_generation_without_api_key[chromium0] FAILED [ 30%]
test_rag_indexing.py::test_rag_chunking_algorithm[chromium0] PASSED      [ 30%]
test_rag_indexing.py::test_rag_embedding_caching[chromium0] PASSED       [ 31%]
test_rag_indexing.py::test_rag_indexing_service_error_handling[chromium0] PASSED [ 31%]
test_rag_indexing.py::test_rag_progress_callback_functionality[chromium0] PASSED [ 32%]
test_rag_integration.py::test_rag_chat_integration_setup[chromium0] PASSED [ 32%]
test_rag_integration.py::test_rag_enhanced_chat_response[chromium0] FAILED [ 33%]
test_rag_integration.py::test_rag_context_injection_mechanism[chromium0] FAILED [ 33%]
test_rag_integration.py::test_rag_search_query_extraction[chromium0] PASSED [ 34%]
test_rag_integration.py::test_rag_end_to_end_workflow[chromium0] FAILED  [ 34%]
test_rag_integration.py::test_rag_no_relevant_context_handling[chromium0] PASSED [ 35%]
test_rag_integration.py::test_rag_multiple_source_integration[chromium0] FAILED [ 35%]
test_rag_integration.py::test_rag_enable_disable_state_integration[chromium0] PASSED [ 36%]
test_rag_integration.py::test_rag_debug_logging_functionality[chromium0] PASSED [ 36%]
test_rag_modal.py::test_rag_button_visibility[chromium0] PASSED          [ 37%]
test_rag_modal.py::test_rag_modal_open_close[chromium0] PASSED           [ 38%]
test_rag_modal.py::test_rag_modal_structure[chromium0] PASSED            [ 38%]
test_rag_modal.py::test_rag_modal_default_prompts_section[chromium0] PASSED [ 39%]
test_rag_modal.py::test_rag_modal_search_section[chromium0] PASSED       [ 39%]
test_rag_modal.py::test_rag_modal_user_bundles_section[chromium0] PASSED [ 40%]
test_rag_modal.py::test_rag_modal_keyboard_interaction[chromium0] PASSED [ 40%]
test_rag_modal.py::test_rag_enable_disable_functionality[chromium0] PASSED [ 41%]
test_rag_modal.py::test_rag_default_prompts_indexing_status[chromium0] PASSED [ 41%]
test_rag_search.py::test_rag_search_ui_elements[chromium0] FAILED        [ 42%]
test_rag_search.py::test_rag_search_without_index[chromium0] FAILED      [ 42%]
test_rag_search.py::test_rag_cosine_similarity_algorithm[chromium0] PASSED [ 43%]
test_rag_search.py::test_rag_search_with_mock_data[chromium0] FAILED     [ 43%]
test_rag_search.py::test_rag_search_ranking_and_relevance[chromium0] PASSED [ 44%]
test_rag_search.py::test_rag_search_enter_key_functionality[chromium0] FAILED [ 44%]
test_rag_search.py::test_rag_search_empty_query_handling[chromium0] FAILED [ 45%]
test_rag_search.py::test_rag_search_result_formatting[chromium0] FAILED  [ 45%]
test_rag_with_precached.py::test_rag_search_with_real_embeddings[chromium0] FAILED [ 46%]
test_sharing.py::test_model_sharing_link_creation[chromium0] SKIPPED     [ 46%]
test_sharing.py::test_model_sharing_link_loading[chromium0] SKIPPED      [ 47%]
test_themes.py::test_theme_toggle_button_exists[chromium0] PASSED        [ 47%]
test_themes.py::test_theme_switching[chromium0] PASSED                   [ 48%]
test_themes.py::test_light_mode_default[chromium0] PASSED                [ 48%]
test_themes.py::test_mobile_utils_loaded[chromium0] PASSED               [ 49%]
test_token_counter_debounce.py::test_token_counter_debounce[chromium0] PASSED [ 50%]
test_button_tooltips.py::test_button_tooltips[chromium1] PASSED          [ 50%]
test_clear_chat.py::test_clear_chat_button_exists[chromium1] PASSED      [ 51%]
test_clear_chat.py::test_clear_chat_confirmation_dialog[chromium1] PASSED [ 51%]
test_clear_namespace_settings.py::test_clear_namespace_settings[chromium1] PASSED [ 52%]
test_context_window_scaling.py::test_context_window_scaling[chromium1] FAILED [ 52%]
test_copy_chat.py::test_copy_chat_button_exists[chromium1] PASSED        [ 53%]
test_copy_chat.py::test_copy_chat_functionality[chromium1] PASSED        [ 53%]
test_copy_chat.py::test_copy_chat_button_tooltip[chromium1] PASSED       [ 54%]
test_debug_mode.py::test_debug_mode_checkbox_exists[chromium1] FAILED    [ 54%]
test_debug_mode.py::test_debug_mode_toggle[chromium1] PASSED             [ 55%]
test_default_prompts.py::test_default_prompts_section_exists[chromium1] PASSED [ 55%]
test_default_prompts.py::test_default_prompts_expand_collapse[chromium1] PASSED [ 56%]
test_default_prompts.py::test_default_prompts_content[chromium1] FAILED  [ 56%]
test_default_prompts.py::test_default_prompts_selection[chromium1] FAILED [ 57%]
test_default_prompts.py::test_default_prompts_info_button[chromium1] PASSED [ 57%]
test_default_prompts.py::test_default_prompts_name_click[chromium1] PASSED [ 58%]
test_function_copy_buttons.py::test_function_copy_buttons_exist[chromium1] PASSED [ 58%]
test_function_copy_buttons.py::test_function_copy_functionality[chromium1] PASSED [ 59%]
test_function_deletion.py::test_function_deletion_removes_entire_bundle[chromium1] PASSED [ 59%]
test_function_deletion.py::test_multiple_function_collections[chromium1] PASSED [ 60%]
test_function_editing.py::test_function_editing[chromium1] PASSED        [ 60%]
test_function_group_colors.py::test_function_collection_colors[chromium1] FAILED [ 61%]
test_function_icons.py::test_function_calling_icons[chromium1] FAILED    [ 61%]
test_function_icons.py::test_multiple_function_calls_colors[chromium1] FAILED [ 62%]
test_function_library_multi.py::test_function_library_multi[chromium1] FAILED [ 63%]
test_function_library_sharing.py::test_function_library_sharing[chromium1] FAILED [ 63%]
test_function_modal.py::test_function_modal_basic[chromium1] PASSED      [ 64%]
test_function_modal.py::test_function_modal_elements[chromium1] PASSED   [ 64%]
test_function_parsing_logic.py::test_all_functions_callable_by_default[chromium1] FAILED [ 65%]
test_function_parsing_logic.py::test_only_tagged_functions_callable[chromium1] FAILED [ 65%]
test_function_parsing_logic.py::test_tool_tag_works[chromium1] FAILED    [ 66%]
test_function_parsing_logic.py::test_single_line_comment_tags[chromium1] FAILED [ 66%]
test_function_parsing_logic.py::test_mixed_tag_types[chromium1] FAILED   [ 67%]
test_function_tooltip.py::test_function_modal_basic[chromium1] PASSED    [ 67%]
test_function_tooltip.py::test_function_modal_elements[chromium1] PASSED [ 68%]
test_input_field_scroll.py::test_input_field_scroll_behavior[chromium1] FAILED [ 68%]
test_input_field_scroll.py::test_input_field_scroll_safari_emulation[chromium1] FAILED [ 69%]
test_logo_tooltip.py::test_heart_logo_tooltip[chromium1] FAILED          [ 69%]
test_modals.py::test_settings_modal[chromium1] PASSED                    [ 70%]
test_modals.py::test_prompts_modal[chromium1] PASSED                     [ 70%]
test_modals.py::test_share_modal[chromium1] PASSED                       [ 71%]
test_model_context_window.py::test_model_context_window_display[chromium1] SKIPPED [ 71%]
test_model_selection_context_window.py::test_context_window_updates_on_model_selection[chromium1] PASSED [ 72%]
test_model_selection_o4_mini.py::test_o4_mini_context_window_display[chromium1] PASSED [ 72%]
test_models_context_simple.py::test_context_window_display[chromium1] FAILED [ 73%]
test_prompt_order_and_function_library_prompt.py::test_user_prompts_before_default_prompts[chromium1] PASSED [ 73%]
test_prompt_order_and_function_library_prompt.py::test_function_library_default_prompt[chromium1] FAILED [ 74%]
test_rag_bundles.py::test_rag_user_bundles_ui_elements[chromium1] FAILED [ 75%]
test_rag_bundles.py::test_rag_bundle_validation_algorithm[chromium1] PASSED [ 75%]
test_rag_bundles.py::test_rag_bundle_storage_operations[chromium1] PASSED [ 76%]
test_rag_bundles.py::test_rag_bundle_display_elements[chromium1] PASSED  [ 76%]
test_rag_bundles.py::test_rag_bundle_file_input_creation[chromium1] PASSED [ 77%]
test_rag_bundles.py::test_rag_bundle_load_button_interaction[chromium1] FAILED [ 77%]
test_rag_bundles.py::test_rag_bundle_removal_confirmation[chromium1] PASSED [ 78%]
test_rag_bundles.py::test_rag_bundle_statistics_accuracy[chromium1] PASSED [ 78%]
test_rag_indexing.py::test_rag_embedding_generation_ui[chromium1] FAILED [ 79%]
test_rag_indexing.py::test_rag_embedding_generation_process[chromium1] FAILED [ 79%]
test_rag_indexing.py::test_rag_embedding_generation_without_api_key[chromium1] FAILED [ 80%]
test_rag_indexing.py::test_rag_chunking_algorithm[chromium1] PASSED      [ 80%]
test_rag_indexing.py::test_rag_embedding_caching[chromium1] PASSED       [ 81%]
test_rag_indexing.py::test_rag_indexing_service_error_handling[chromium1] PASSED [ 81%]
test_rag_indexing.py::test_rag_progress_callback_functionality[chromium1] PASSED [ 82%]
test_rag_integration.py::test_rag_chat_integration_setup[chromium1] PASSED [ 82%]
test_rag_integration.py::test_rag_enhanced_chat_response[chromium1] FAILED [ 83%]
test_rag_integration.py::test_rag_context_injection_mechanism[chromium1] FAILED [ 83%]
test_rag_integration.py::test_rag_search_query_extraction[chromium1] PASSED [ 84%]
test_rag_integration.py::test_rag_end_to_end_workflow[chromium1] FAILED  [ 84%]
test_rag_integration.py::test_rag_no_relevant_context_handling[chromium1] PASSED [ 85%]
test_rag_integration.py::test_rag_multiple_source_integration[chromium1] FAILED [ 85%]
test_rag_integration.py::test_rag_enable_disable_state_integration[chromium1] PASSED [ 86%]
test_rag_integration.py::test_rag_debug_logging_functionality[chromium1] PASSED [ 86%]
test_rag_modal.py::test_rag_button_visibility[chromium1] PASSED          [ 87%]
test_rag_modal.py::test_rag_modal_open_close[chromium1] PASSED           [ 88%]
test_rag_modal.py::test_rag_modal_structure[chromium1] PASSED            [ 88%]
test_rag_modal.py::test_rag_modal_default_prompts_section[chromium1] PASSED [ 89%]
test_rag_modal.py::test_rag_modal_search_section[chromium1] PASSED       [ 89%]
test_rag_modal.py::test_rag_modal_user_bundles_section[chromium1] PASSED [ 90%]
test_rag_modal.py::test_rag_modal_keyboard_interaction[chromium1] PASSED [ 90%]
test_rag_modal.py::test_rag_enable_disable_functionality[chromium1] PASSED [ 91%]
test_rag_modal.py::test_rag_default_prompts_indexing_status[chromium1] PASSED [ 91%]
test_rag_search.py::test_rag_search_ui_elements[chromium1] FAILED        [ 92%]
test_rag_search.py::test_rag_search_without_index[chromium1] FAILED      [ 92%]
test_rag_search.py::test_rag_cosine_similarity_algorithm[chromium1] PASSED [ 93%]
test_rag_search.py::test_rag_search_with_mock_data[chromium1] FAILED     [ 93%]
test_rag_search.py::test_rag_search_ranking_and_relevance[chromium1] PASSED [ 94%]
test_rag_search.py::test_rag_search_enter_key_functionality[chromium1] FAILED [ 94%]
test_rag_search.py::test_rag_search_empty_query_handling[chromium1] FAILED [ 95%]
test_rag_search.py::test_rag_search_result_formatting[chromium1] FAILED  [ 95%]
test_rag_with_precached.py::test_rag_search_with_real_embeddings[chromium1] FAILED [ 96%]
test_sharing.py::test_model_sharing_link_creation[chromium1] SKIPPED     [ 96%]
test_sharing.py::test_model_sharing_link_loading[chromium1] SKIPPED      [ 97%]
test_themes.py::test_theme_toggle_button_exists[chromium1] PASSED        [ 97%]
test_themes.py::test_theme_switching[chromium1] PASSED                   [ 98%]
test_themes.py::test_light_mode_default[chromium1] PASSED                [ 98%]
test_themes.py::test_mobile_utils_loaded[chromium1] PASSED               [ 99%]
test_token_counter_debounce.py::test_token_counter_debounce[chromium1] PASSED [100%]

=================================== FAILURES ===================================
____________________ test_context_window_scaling[chromium0] ____________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_context_window_scaling(page: Page, serve_hacka_re):
        """Test that the context window meter scales with the model's context size."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=2000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Enter the API key
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(API_KEY)
    
        # Select OpenAI as the API provider
        base_url_select = page.locator("#base-url-select")
        base_url_select.select_option("openai")
    
        # Click the reload models button
        reload_button = page.locator("#model-reload-btn")
        reload_button.click()
    
        # Wait for the models to be loaded
        # First, check if the model select has any non-disabled options
        try:
            page.wait_for_selector("#model-select option:not([disabled])", state="visible", timeout=2000)
            print("Models loaded successfully")
        except Exception as e:
            print(f"Error waiting for models to load: {e}")
            # Force a longer wait time
            time.sleep(0.5)
    
            # Check if there are any options in the model select
            options_count = page.evaluate("""() => {
                const select = document.getElementById('model-select');
                if (!select) return 0;
                return Array.from(select.options).filter(opt => !opt.disabled).length;
            }""")
            print(f"Found {options_count} non-disabled options in model select")
    
            if options_count == 0:
                # Try clicking the reload button again
                print("No options found, clicking reload button again")
>               reload_button.click()

test_context_window_scaling.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:15512: in click
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_locator.py:160: in click
    return await self._frame.click(self._selector, strict=True, **params)
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:488: in click
    await self._channel.send("click", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x10405f1a0>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Locator.click: Timeout 10000ms exceeded.
E           Call log:
E             - waiting for locator("#model-reload-btn")
E               - locator resolved to <button disabled type="button" class="icon-btn" id="model-reload-btn" title="Reload models from API">‚Ä¶</button>
E             - attempting click action
E               2 √ó waiting for element to be visible, enabled and stable
E                 - element is not enabled
E               - retrying click action
E               - waiting 20ms
E               2 √ó waiting for element to be visible, enabled and stable
E                 - element is not enabled
E               - retrying click action
E                 - waiting 100ms
E               19 √ó waiting for element to be visible, enabled and stable
E                  - element is not enabled
E                - retrying click action
E                  - waiting 500ms

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Error waiting for models to load: Page.wait_for_selector: Timeout 2000ms exceeded.
Call log:
  - waiting for locator("#model-select option:not([disabled])") to be visible

Found 0 non-disabled options in model select
No options found, clicking reload button again
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
__________________ test_debug_mode_checkbox_exists[chromium0] __________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_debug_mode_checkbox_exists(page, serve_hacka_re):
        """Test that the debug mode checkbox exists in the settings modal."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        from test_utils import dismiss_welcome_modal
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Open settings modal
        page.click("#settings-btn")
    
        # Wait for settings modal to be visible
        expect(page.locator("#settings-modal")).to_be_visible()
    
        # Scroll to the system prompt section to ensure the debug checkbox is in view
        page.locator("#open-prompts-config").scroll_into_view_if_needed()
    
        # Wait for debug mode checkbox to be added dynamically
        debug_checkbox = page.locator("#debug-mode")
        debug_checkbox.wait_for(state="visible", timeout=2000)
    
        # Check if the label text is correct
        debug_label = page.locator("label[for='debug-mode']")
        expect(debug_label).to_be_visible()
>       expect(debug_label).to_have_text("Debug mode")
E       AssertionError: Locator expected to have text 'Debug mode'
E       Actual value: Debug mode(Disabled) 
E       Call log:
E         - LocatorAssertions.to_have_text with timeout 5000ms
E         - waiting for locator("label[for='debug-mode']")
E           9 √ó locator resolved to <label for="debug-mode">‚Ä¶</label>
E             - unexpected value "Debug mode(Disabled)"

test_debug_mode.py:30: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
___________________ test_default_prompts_content[chromium0] ____________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_default_prompts_content(page, serve_hacka_re):
        """Test that the default prompts section contains the expected content."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if present
        # Wait a moment for the page to fully load
        # page.wait_for_timeout(500)  # TODO: Replace with proper wait condition
    
        # Click the prompts button
        prompts_button = page.locator("#prompts-btn")
        prompts_button.click()
    
        # Check that the prompts modal is visible
        prompts_modal = page.locator("#prompts-modal")
        expect(prompts_modal).to_be_visible()
    
        # Click the default prompts header to expand
        default_prompts_header = page.locator(".default-prompts-header")
        default_prompts_header.click()
    
        # Check that the default prompts list is now visible (expanded)
        default_prompts_list = page.locator(".default-prompts-list")
        expect(default_prompts_list).to_be_visible()
    
        # Check that there are at least one default prompt item
        default_prompt_items = page.locator(".default-prompt-item")
        count = default_prompt_items.count()
        assert count >= 1, f"Expected at least 1 default prompt item, but found {count}"
    
        # Check that one of the default prompts is about the hacka.re project
        hacka_re_prompt = page.locator(".default-prompt-item:has-text('About hacka.re Project')")
>       expect(hacka_re_prompt).to_be_visible()
E       AssertionError: Locator expected to be visible
E       Actual value: <element(s) not found> 
E       Call log:
E         - LocatorAssertions.to_be_visible with timeout 5000ms
E         - waiting for locator(".default-prompt-item:has-text('About hacka.re Project')")

test_default_prompts.py:137: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
__________________ test_default_prompts_selection[chromium0] ___________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_default_prompts_selection(page, serve_hacka_re):
        """Test that default prompts can be selected and deselected."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if present
        # Wait a moment for the page to fully load
        # page.wait_for_timeout(500)  # TODO: Replace with proper wait condition
    
        # Click the prompts button
        prompts_button = page.locator("#prompts-btn")
        prompts_button.click()
    
        # Check that the prompts modal is visible
        prompts_modal = page.locator("#prompts-modal")
        expect(prompts_modal).to_be_visible()
    
        # Click the default prompts header to expand
        default_prompts_header = page.locator(".default-prompts-header")
        default_prompts_header.click()
    
        # Check that the default prompts list is now visible (expanded)
        default_prompts_list = page.locator(".default-prompts-list")
        expect(default_prompts_list).to_be_visible()
    
        # Define the prompts to test
        prompts_to_test = [
            ".default-prompt-item:has-text('About hacka.re Project')",
            ".default-prompt-item:has-text('OWASP Top 10 for LLM Applications')"
        ]
    
        # Test each prompt
        for prompt_selector in prompts_to_test:
            # Find the prompt
            prompt = page.locator(prompt_selector)
>           expect(prompt).to_be_visible()
E           AssertionError: Locator expected to be visible
E           Actual value: <element(s) not found> 
E           Call log:
E             - LocatorAssertions.to_be_visible with timeout 5000ms
E             - waiting for locator(".default-prompt-item:has-text('About hacka.re Project')")

test_default_prompts.py:197: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
__________________ test_function_collection_colors[chromium0] __________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_function_collection_colors(page: Page, serve_hacka_re, api_key):
        """Test that functions from the same import are collected by color and deletion works for the entire collection."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_group_colors.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
____________________ test_function_calling_icons[chromium0] ____________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_function_calling_icons(page: Page, serve_hacka_re, api_key):
        """Test that function calling icons appear inline with the token stream."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_icons.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
________________ test_multiple_function_calls_colors[chromium0] ________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_multiple_function_calls_colors(page: Page, serve_hacka_re, api_key):
        """Test that multiple function calls use different colors."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_icons.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
____________________ test_function_library_multi[chromium0] ____________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_function_library_multi(page: Page, serve_hacka_re, api_key):
        """Test the multi-function library with @tool tag."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_library_multi.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
___________________ test_function_library_sharing[chromium0] ___________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_function_library_sharing(page: Page, serve_hacka_re):
        """
        Test that function library can be shared and loaded from a shared link.
    
        This test:
        1. Creates a test function
        2. Shares it using the function library option
        3. Deletes the function
        4. Loads the shared link
        5. Verifies the function is restored
        """
        # STEP 1: Navigate to the application
        page.goto(serve_hacka_re)
    
        # STEP 2: Handle welcome and settings modals
        dismiss_welcome_modal(page)
        # STEP 3: Configure API key and model
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click()
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible")
    
        # Enter the API key
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(API_KEY)
    
        # Select OpenAI as the API provider
        base_url_select = page.locator("#base-url-select")
        base_url_select.select_option("openai")
    
        # Select a model
        from test_utils import select_recommended_test_model
        selected_model = select_recommended_test_model(page)
    
        # Settings auto-save, wait and close
        page.wait_for_timeout(1000)
        close_button = page.locator("#close-settings")
        close_button.click()
    
        # Wait for the settings modal to be closed
        page.wait_for_selector("#settings-modal", state="hidden")
    
        # STEP 4: Create a test function
        # Open the function modal
        function_btn = page.locator("#function-btn")
        function_btn.click()
    
        # Wait for the function modal to be visible
        function_modal = page.locator("#function-modal")
        expect(function_modal).to_be_visible()
    
        # First, set the function code - the name field will be auto-populated
        function_name = "test_shared_function"
        function_code = f"""function {function_name}(text) {{
      return {{
        message: "You said: " + text,
        timestamp: new Date().toISOString()
      }};
    }}"""
    
        function_code_input = page.locator("#function-code")
        function_code_input.scroll_into_view_if_needed()
        expect(function_code_input).to_be_visible()
        function_code_input.fill(function_code)
    
        # Trigger the auto-population by firing an input event
        page.evaluate("""() => {
            const codeTextarea = document.getElementById('function-code');
            if (codeTextarea) {
                codeTextarea.dispatchEvent(new Event('input', { bubbles: true }));
            }
        }""")
    
        # Wait a moment for auto-population to happen
        # page.wait_for_timeout(500)  # TODO: Replace with proper wait condition
    
        # Verify the function name field was auto-populated
        name_value = page.evaluate("""() => {
            const nameField = document.getElementById('function-name');
            return nameField ? nameField.value : null;
        }""")
    
        if name_value:
            assert name_value == function_name, f"Expected '{function_name}', got '{name_value}'"
    
        # Validate the function
        validate_btn = page.locator("#function-validate-btn")
        validate_btn.scroll_into_view_if_needed()
        expect(validate_btn).to_be_visible()
        validate_btn.click()
    
        # Wait for validation result
        validation_result = page.locator("#function-validation-result")
        page.wait_for_selector("#function-validation-result:not(:empty)", state="visible")
        expect(validation_result).to_contain_text("Library validated successfully")
    
        # Save the function
        save_btn = page.locator("#function-editor-form button[type='submit']")
        save_btn.scroll_into_view_if_needed()
        expect(save_btn).to_be_visible()
        save_btn.click()
    
        # Verify the function was added to the list
        function_list = page.locator("#function-list")
        page.wait_for_selector(f".function-item-name:has-text('{function_name}')", state="visible")
        expect(function_list.locator(f".function-item-name:has-text('{function_name}')")).to_be_visible()
    
        # Take a screenshot after adding the function
        screenshot_with_markdown(page, "function_library_sharing_function_added", {
            "step": "Added test function for sharing",
            "function_name": function_name
        })
    
        # Close the function modal
        close_function_modal_btn = page.locator("#close-function-modal")
        close_function_modal_btn.click()
    
        # STEP 5: Share the function library
        # Open the share modal
        share_btn = page.locator("#share-btn")
        share_btn.click()
    
        # Wait for the share modal to be visible
        share_modal = page.locator("#share-modal")
        expect(share_modal).to_be_visible()
    
        # Set a test password
        test_password = "TestPassword123"
        password_input = page.locator("#share-password")
        password_input.fill(test_password)
    
        # Check the function library checkbox
        function_library_checkbox = page.locator("#share-function-library")
        function_library_checkbox.check()
    
        # Also check API key checkbox to ensure we have something to share
        api_key_checkbox = page.locator("#share-api-key")
        api_key_checkbox.check()
    
        # Take a screenshot of the share modal
        screenshot_with_markdown(page, "function_library_sharing_share_modal", {
            "step": "Share modal with function library option checked",
            "password": test_password,
            "function_library_checked": function_library_checkbox.is_checked(),
            "api_key_checked": api_key_checkbox.is_checked()
        })
    
        # Generate the share link
        generate_link_btn = page.locator("#generate-share-link-btn")
        generate_link_btn.click()
    
        # Wait a moment for the link generation process
        # page.wait_for_timeout(1000)  # TODO: Replace with proper wait condition
    
        # Take a screenshot after clicking generate button
        screenshot_with_markdown(page, "function_library_sharing_after_generate", {
            "step": "After clicking generate link button",
            "container_visible": page.locator("#generated-link-container").is_visible()
        })
    
        # Wait for the link to be generated
        generated_link_container = page.locator("#generated-link-container")
        expect(generated_link_container).to_be_visible()
    
        # Get the generated link
        generated_link = page.locator("#generated-link").input_value()
    
        # Validate the link is not empty and has the expected format
        assert generated_link, "Generated link is empty"
        assert "#gpt=" in generated_link, f"Generated link doesn't contain #gpt= fragment: {generated_link}"
    
        # Take a screenshot of the generated link
        screenshot_with_markdown(page, "function_library_sharing_generated_link", {
            "step": "Generated share link",
            "link_length": len(generated_link),
            "link_preview": generated_link[:100] + "..." if len(generated_link) > 100 else generated_link,
            "has_gpt_fragment": "#gpt=" in generated_link
        })
    
        # Close the share modal
        close_share_modal_btn = page.locator("#close-share-modal")
        close_share_modal_btn.click()
    
        # STEP 6: Delete the function
        # Open the function modal again
        function_btn.click()
        expect(function_modal).to_be_visible()
    
        # Delete the function
        # Handle the confirmation dialog
        page.on("dialog", lambda dialog: dialog.accept())
    
        # Find and click the delete button for the function
        # The delete button is in the same function-item div as the function name
        function_item = page.locator(f"#function-list .function-item").filter(has=page.locator(f".function-item-name:has-text('{function_name}')"))
        delete_btn = function_item.locator(".function-item-delete")
>       delete_btn.click()

test_function_library_sharing.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:15512: in click
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_locator.py:160: in click
    return await self._frame.click(self._selector, strict=True, **params)
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:488: in click
    await self._channel.send("click", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x104063ec0>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Locator.click: Timeout 10000ms exceeded.
E           Call log:
E             - waiting for locator("#function-list .function-item").filter(has=locator(".function-item-name:has-text('test_shared_function')")).locator(".function-item-delete")

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Available options in model select dropdown:
  Option: -- Default models (API unavailable) -- (value: , disabled: True)
  Option: üá∫üá∏ Gpt 4o Mini (value: gpt-4o-mini, disabled: False)
  Option: üá∫üá∏ Gpt 4o (value: gpt-4o, disabled: False)
  Option: üá∫üá∏ Gpt 4 Turbo (value: gpt-4-turbo, disabled: False)
  Option: üá∫üá∏ Gpt 3.5 Turbo (value: gpt-3.5-turbo, disabled: False)
Recommended model not available. Selecting first option: gpt-4o-mini
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
______________ test_all_functions_callable_by_default[chromium0] _______________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_all_functions_callable_by_default(page: Page, serve_hacka_re, api_key):
        """Test that all functions are callable by default when no tags are present."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_parsing_logic.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
________________ test_only_tagged_functions_callable[chromium0] ________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_only_tagged_functions_callable(page: Page, serve_hacka_re, api_key):
        """Test that only tagged functions are callable when at least one tag is present."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_parsing_logic.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
________________________ test_tool_tag_works[chromium0] ________________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_tool_tag_works(page: Page, serve_hacka_re, api_key):
        """Test that the @tool tag works the same as @callable."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_parsing_logic.py:272: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
___________________ test_single_line_comment_tags[chromium0] ___________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_single_line_comment_tags(page: Page, serve_hacka_re, api_key):
        """Test that single-line comment tags work."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_parsing_logic.py:395: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_______________________ test_mixed_tag_types[chromium0] ________________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_mixed_tag_types(page: Page, serve_hacka_re, api_key):
        """Test that mixed tag types work together."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_parsing_logic.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_________________ test_input_field_scroll_behavior[chromium0] __________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_input_field_scroll_behavior(page: Page, serve_hacka_re):
        """Test that focusing the input field doesn't scroll past the footer."""
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if present
        # Take a screenshot of the initial state
        screenshot_with_markdown(page, "input_field_scroll_initial.png", {
            "Status": "Initial page load",
            "Test": "Input field scroll behavior",
            "Description": "Checking that input field focus doesn't scroll past the footer"
        })
    
        # Get the footer element for position reference
        footer = page.locator("footer")
>       expect(footer).to_be_visible()
E       AssertionError: Locator expected to be visible
E       Actual value: <element(s) not found> 
E       Call log:
E         - LocatorAssertions.to_be_visible with timeout 5000ms
E         - waiting for locator("footer")

test_input_field_scroll.py:23: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_____________ test_input_field_scroll_safari_emulation[chromium0] ______________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_input_field_scroll_safari_emulation(page: Page, serve_hacka_re):
        """Test input field scroll behavior with Safari emulation."""
        # Configure the context to emulate Safari on iOS
        page.context.add_cookies([{
            "name": "safari-emulation",
            "value": "true",
            "url": serve_hacka_re,
        }])
    
        # Set Safari user agent
        page.set_extra_http_headers({
            "User-Agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1"
        })
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if present
        # Take a screenshot of the initial state with Safari emulation
        screenshot_with_markdown(page, "safari_input_field_scroll_initial.png", {
            "Status": "Initial page load with Safari emulation",
            "Test": "Safari input field scroll behavior",
            "Description": "Checking that input field focus doesn't scroll past the footer in Safari"
        })
    
        # Get the footer element for position reference
        footer = page.locator("footer")
>       expect(footer).to_be_visible()
E       AssertionError: Locator expected to be visible
E       Actual value: <element(s) not found> 
E       Call log:
E         - LocatorAssertions.to_be_visible with timeout 5000ms
E         - waiting for locator("footer")

test_input_field_scroll.py:105: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
______________________ test_heart_logo_tooltip[chromium0] ______________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_heart_logo_tooltip(page: Page, serve_hacka_re):
        """Test that the heart logo modal appears when clicking on various elements."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if present
        # Take a screenshot of the initial state
        screenshot_with_markdown(page, "heart_logo_tooltip_initial", {
            "Status": "Initial state before clicking",
            "Component": "Heart Logo Modal"
        })
    
        # Check that the logo info modal is initially hidden
        logo_modal = page.locator("#logo-info-modal")
        expect(logo_modal).not_to_be_visible()
    
        # Test clicking on the heart logo
        heart_logo = page.locator(".heart-logo")
        expect(heart_logo).to_be_visible()
    
        # Click on the heart logo
        heart_logo.click()
    
        # Check that the modal is now visible
>       expect(logo_modal).to_be_visible()
E       AssertionError: Locator expected to be visible
E       Actual value: <element(s) not found> 
E       Call log:
E         - LocatorAssertions.to_be_visible with timeout 5000ms
E         - waiting for locator("#logo-info-modal")

test_logo_tooltip.py:32: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
________________ test_o4_mini_context_window_display[chromium0] ________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_o4_mini_context_window_display(page: Page, serve_hacka_re):
        """Test that the o4-mini model's context window size (200k tokens) is correctly displayed."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=2000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Enter the API key
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(API_KEY)
    
        # Select OpenAI as the API provider
        base_url_select = page.locator("#base-url-select")
        base_url_select.select_option("openai")
    
        # Click the reload models button
        reload_button = page.locator("#model-reload-btn")
        reload_button.click()
    
        # Wait for the models to be loaded
        try:
            page.wait_for_selector("#model-select option:not([disabled])", state="visible", timeout=2000)
            print("Models loaded successfully")
        except Exception as e:
            print(f"Error waiting for models to load: {e}")
            # Force a longer wait time
            time.sleep(0.5)
    
            # Check if there are any options in the model select
            options_count = page.evaluate("""() => {
                const select = document.getElementById('model-select');
                if (!select) return 0;
                return Array.from(select.options).filter(opt => !opt.disabled).length;
            }""")
            print(f"Found {options_count} non-disabled options in model select")
    
            if options_count == 0:
                # Try clicking the reload button again
                print("No options found, clicking reload button again")
>               reload_button.click()

test_model_selection_o4_mini.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:15512: in click
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_locator.py:160: in click
    return await self._frame.click(self._selector, strict=True, **params)
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:488: in click
    await self._channel.send("click", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x104e531a0>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Locator.click: Timeout 10000ms exceeded.
E           Call log:
E             - waiting for locator("#model-reload-btn")
E               - locator resolved to <button disabled type="button" class="icon-btn" id="model-reload-btn" title="Reload models from API">‚Ä¶</button>
E             - attempting click action
E               2 √ó waiting for element to be visible, enabled and stable
E                 - element is not enabled
E               - retrying click action
E               - waiting 20ms
E               2 √ó waiting for element to be visible, enabled and stable
E                 - element is not enabled
E               - retrying click action
E                 - waiting 100ms
E               19 √ó waiting for element to be visible, enabled and stable
E                  - element is not enabled
E                - retrying click action
E                  - waiting 500ms

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Error waiting for models to load: Page.wait_for_selector: Timeout 2000ms exceeded.
Call log:
  - waiting for locator("#model-select option:not([disabled])") to be visible

Found 0 non-disabled options in model select
No options found, clicking reload button again
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
____________________ test_context_window_display[chromium0] ____________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_context_window_display(page: Page, serve_hacka_re, api_key):
        """Test that context window is displayed in the UI"""
    
        # Navigate to the page
        page.goto(serve_hacka_re)
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Open settings
        settings_btn = page.locator("#settings-btn")
        settings_btn.click()
        page.wait_for_selector("#settings-modal", state="visible")
    
        # Configure OpenAI API
        api_key_input = page.locator("#api-key-input")
>       api_key_input.fill(api_key)

test_models_context_simple.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:15851: in fill
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_locator.py:212: in fill
    return await self._frame.fill(self._selector, strict=True, **params)
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x104181300>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Locator.fill: Timeout 10000ms exceeded.
E           Call log:
E             - waiting for locator("#api-key-input")

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_______________ test_function_library_default_prompt[chromium0] ________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_function_library_default_prompt(page: Page, serve_hacka_re):
        """Test that the 'Function library' default prompt is available and works correctly."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Check if settings modal is already open and dismiss it
        settings_modal = page.locator("#settings-modal")
        if settings_modal.is_visible():
            print("Settings modal is already open, dismissing it first")
            # Wait a moment to ensure the modal is fully closed
            time.sleep(0.5)
    
        # Take a screenshot at the start
        screenshot_with_markdown(page, "function_library_prompt_test_start.png", {
            "Status": "Test started",
            "Test Name": "Function Library Default Prompt",
            "Description": "Verifying that the Function Library default prompt exists and works correctly"
        })
    
        # First, create a function in the function library
        page.locator("#function-btn").click()
    
        # Wait for the function modal to be visible
        function_modal = page.locator("#function-modal")
        expect(function_modal).to_be_visible()
    
        # Fill in the function code
        function_code = """
    /**
     * A test function for the function library prompt
     * @description This is a test function
     * @param {string} input - Input string
     * @returns {Object} Result object
     */
    function test_function(input) {
      return {
        result: `Processed: ${input}`,
        timestamp: new Date().toISOString()
      };
    }
    """
        page.locator("#function-code").fill(function_code)
    
        # Save the function
        page.locator("#function-editor-form button[type='submit']").click()
    
        # Wait for the function to be saved
        page.wait_for_timeout(1000)
    
        # Take a screenshot after creating the function
        screenshot_with_markdown(page, "function_created.png", {
            "Status": "Function created",
            "Function Name": "test_function",
            "Test Name": "Function Library Default Prompt"
        })
    
        # Close the function modal
        page.locator("#close-function-modal").click()
        expect(function_modal).not_to_be_visible()
    
        # Reload the page to ensure the function is properly saved and loaded
        page.reload()
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Check if settings modal is already open and dismiss it
        settings_modal = page.locator("#settings-modal")
        if settings_modal.is_visible():
            print("Settings modal is already open after reload, dismissing it")
            # Wait a moment to ensure the modal is fully closed
            time.sleep(0.5)
    
        # Open the prompts modal
        page.locator("#prompts-btn").click()
    
        # Check that the prompts modal is visible
        prompts_modal = page.locator("#prompts-modal")
        expect(prompts_modal).to_be_visible()
    
        # Expand the default prompts section
        page.locator(".default-prompts-header").click()
    
        # Wait for the default prompts list to be visible
        default_prompts_list = page.locator(".default-prompts-list")
        expect(default_prompts_list).to_be_visible()
    
        # Check if the Code section exists and expand it if it does
        code_section = page.locator(".nested-section-header:has-text('Code')")
        if code_section.count() > 0:
            print("Found Code section, expanding it")
            code_section.click()
    
            # Wait for the nested section list to be visible
            nested_list = page.locator(".nested-section-list")
            expect(nested_list).to_be_visible()
    
        # Check if the "Function Library" prompt exists
        function_library_prompt = page.locator(".default-prompt-item:has-text('Function library')")
>       expect(function_library_prompt).to_be_visible()
E       AssertionError: Locator expected to be visible
E       Actual value: <element(s) not found> 
E       Call log:
E         - LocatorAssertions.to_be_visible with timeout 5000ms
E         - waiting for locator(".default-prompt-item:has-text('Function library')")

test_prompt_order_and_function_library_prompt.py:194: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_________________ test_rag_user_bundles_ui_elements[chromium0] _________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_user_bundles_ui_elements(page: Page, serve_hacka_re):
        """Test the user bundles UI elements and basic functionality."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Check user bundles section elements
        user_bundles_section = page.locator("#rag-user-bundles-section")
>       expect(user_bundles_section).to_be_visible()
E       AssertionError: Locator expected to be visible
E       Actual value: <element(s) not found> 
E       Call log:
E         - LocatorAssertions.to_be_visible with timeout 5000ms
E         - waiting for locator("#rag-user-bundles-section")

test_rag_bundles.py:25: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
______________ test_rag_bundle_load_button_interaction[chromium0] ______________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_bundle_load_button_interaction(page: Page, serve_hacka_re):
        """Test the load bundle button interaction."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Check load bundle button
        load_bundle_btn = page.locator("#load-user-bundle-btn")
>       expect(load_bundle_btn).to_be_visible()
E       AssertionError: Locator expected to be visible
E       Actual value: <element(s) not found> 
E       Call log:
E         - LocatorAssertions.to_be_visible with timeout 5000ms
E         - waiting for locator("#load-user-bundle-btn")

test_rag_bundles.py:362: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_________________ test_rag_embedding_generation_ui[chromium0] __________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_rag_embedding_generation_ui(page: Page, serve_hacka_re, api_key):
        """Test the RAG embedding generation UI and progress indicators."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Configure API key first
        page.evaluate(f"localStorage.setItem('openai_api_key', '{api_key}')")
        page.evaluate("localStorage.setItem('base_url', 'https://api.openai.com/v1')")
        page.evaluate("localStorage.setItem('selected_model', 'gpt-4o-mini')")
    
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Check initial state of embedding generation section
        generate_btn = page.locator("#generate-default-prompts-embeddings")
>       expect(generate_btn).to_be_visible()
E       AssertionError: Locator expected to be visible
E       Actual value: <element(s) not found> 
E       Call log:
E         - LocatorAssertions.to_be_visible with timeout 5000ms
E         - waiting for locator("#generate-default-prompts-embeddings")

test_rag_indexing.py:28: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_______________ test_rag_embedding_generation_process[chromium0] _______________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_rag_embedding_generation_process(page: Page, serve_hacka_re, api_key):
        """Test the actual embedding generation process with real API calls."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Configure API key and settings
        page.evaluate(f"localStorage.setItem('openai_api_key', '{api_key}')")
        page.evaluate("localStorage.setItem('base_url', 'https://api.openai.com/v1')")
        page.evaluate("localStorage.setItem('selected_model', 'gpt-4o-mini')")
    
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Click generate embeddings button
        generate_btn = page.locator("#generate-default-prompts-embeddings")
>       generate_btn.click()

test_rag_indexing.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:15512: in click
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_locator.py:160: in click
    return await self._frame.click(self._selector, strict=True, **params)
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:488: in click
    await self._channel.send("click", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x104114b80>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Locator.click: Timeout 10000ms exceeded.
E           Call log:
E             - waiting for locator("#generate-default-prompts-embeddings")

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
___________ test_rag_embedding_generation_without_api_key[chromium0] ___________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_embedding_generation_without_api_key(page: Page, serve_hacka_re):
        """Test embedding generation behavior without API key."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Ensure no API key is set
        page.evaluate("localStorage.removeItem('openai_api_key')")
    
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Try to click generate embeddings button
        generate_btn = page.locator("#generate-default-prompts-embeddings")
>       generate_btn.click()

test_rag_indexing.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:15512: in click
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_locator.py:160: in click
    return await self._frame.click(self._selector, strict=True, **params)
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:488: in click
    await self._channel.send("click", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x103fe1760>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Locator.click: Timeout 10000ms exceeded.
E           Call log:
E             - waiting for locator("#generate-default-prompts-embeddings")

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
__________________ test_rag_enhanced_chat_response[chromium0] __________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_rag_enhanced_chat_response(page: Page, serve_hacka_re, api_key):
        """Test that chat responses are enhanced with RAG context and verify content inclusion."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Configure API key and settings
        page.evaluate(f"localStorage.setItem('openai_api_key', '{api_key}')")
        page.evaluate("localStorage.setItem('base_url', 'https://api.openai.com/v1')")
        page.evaluate("localStorage.setItem('selected_model', 'gpt-4o-mini')")
    
        # Enable debug mode and RAG category to capture debug logs
        page.evaluate("""
            window.DebugService.setDebugMode(true);
            window.DebugService.setCategoryEnabled('rag', true);
        """)
    
        # Create comprehensive mock RAG index with very specific content that should be identifiable in responses
        specific_rag_index = {
            "chunks": [
                {
                    "content": "UNIQUE_RAG_MARKER: Test-driven development (TDD) follows the Red-Green-Refactor cycle: write a failing test (Red), write minimal code to make it pass (Green), then improve the code structure (Refactor). This approach ensures high code quality and comprehensive test coverage.",
                    "embedding": [0.9, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                    "metadata": {
                        "promptId": "tdd_process",
                        "promptName": "Test-Driven Development Process",
                        "type": "default_prompt"
                    },
                    "id": "chunk_tdd_specific"
                }
            ],
            "metadata": {
                "totalChunks": 1,
                "embeddingModel": "text-embedding-3-small"
            }
        }
    
        # Store mock index
        page.evaluate(f"localStorage.setItem('rag_default_prompts_index', '{json.dumps(specific_rag_index)}')")
    
        # Send a chat message that should match our specific RAG content
        chat_input = page.locator("#chat-input")
        send_button = page.locator("#send-btn")
    
        # Type a question that should trigger our specific RAG content
        test_question = "What is test-driven development and how does it work?"
>       chat_input.fill(test_question)

test_rag_integration.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:15851: in fill
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_locator.py:212: in fill
    return await self._frame.fill(self._selector, strict=True, **params)
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x104e20720>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Locator.fill: Timeout 10000ms exceeded.
E           Call log:
E             - waiting for locator("#chat-input")

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_______________ test_rag_context_injection_mechanism[chromium0] ________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_context_injection_mechanism(page: Page, serve_hacka_re):
        """Test the RAG context injection mechanism without making API calls."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Create mock RAG index
        mock_index = {
            "chunks": [
                {
                    "content": "Context about web development: HTML, CSS, and JavaScript are the core technologies for building web applications.",
                    "embedding": [0.8, 0.2, 0.0, 0.0, 0.0],
                    "metadata": {"promptName": "Web Development Basics"},
                    "id": "chunk_web_dev"
                }
            ],
            "metadata": {"totalChunks": 1}
        }
    
        page.evaluate(f"localStorage.setItem('rag_default_prompts_index', '{json.dumps(mock_index)}')")
    
        # Test context injection through browser console
        context_injection_result = page.evaluate("""() => {
            // Mock a user message about web development
            const userMessage = "How do I build a website?";
    
            // Test if we can perform RAG search
            try {
                const searchResults = window.VectorRAGService.search(userMessage, {}, 1);
    
                // Check if context formatting works
                if (searchResults && searchResults.length > 0) {
                    const formattedContext = window.VectorRAGService.formatResultsForContext(searchResults);
    
                    return {
                        searchPerformed: true,
                        resultsFound: searchResults.length > 0,
                        contextFormatted: formattedContext && formattedContext.length > 0,
                        contextContent: formattedContext,
                        searchResults: searchResults
                    };
                }
    
                return {
                    searchPerformed: true,
                    resultsFound: false,
                    contextFormatted: false
                };
            } catch (error) {
                return {
                    searchPerformed: false,
                    error: error.message
                };
            }
        }""")
    
        # Verify context injection mechanism
        assert context_injection_result['searchPerformed'], "RAG search should be performed"
>       assert context_injection_result['resultsFound'], "Relevant results should be found"
E       AssertionError: Relevant results should be found
E       assert False

test_rag_integration.py:289: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
___________________ test_rag_end_to_end_workflow[chromium0] ____________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_rag_end_to_end_workflow(page: Page, serve_hacka_re, api_key):
        """Test complete end-to-end RAG workflow from indexing to chat response."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Configure API key and settings
        page.evaluate(f"localStorage.setItem('openai_api_key', '{api_key}')")
        page.evaluate("localStorage.setItem('base_url', 'https://api.openai.com/v1')")
        page.evaluate("localStorage.setItem('selected_model', 'gpt-4o-mini')")
    
        # Step 1: Create and store a knowledge base
        mock_knowledge_base = {
            "chunks": [
                {
                    "content": "Test-driven development (TDD) is a software development approach where tests are written before the actual code. The cycle involves writing a failing test, writing minimal code to pass the test, and then refactoring.",
                    "embedding": [0.9, 0.1, 0.0, 0.0, 0.0],
                    "metadata": {
                        "promptId": "tdd_guide",
                        "promptName": "Test-Driven Development Guide",
                        "type": "default_prompt"
                    },
                    "id": "chunk_tdd"
                }
            ],
            "metadata": {"totalChunks": 1, "embeddingModel": "text-embedding-3-small"}
        }
    
        page.evaluate(f"localStorage.setItem('rag_default_prompts_index', '{json.dumps(mock_knowledge_base)}')")
    
        # Step 2: Open RAG modal and verify search functionality
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Test search in RAG modal
        search_input = page.locator("#rag-search-input")
        search_button = page.locator("#rag-search-btn")
    
        search_input.fill("test driven development")
        search_button.click()
    
        # Wait for and verify search results
>       page.wait_for_selector("#rag-search-results .rag-search-result", timeout=5000)

test_rag_integration.py:408: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:8187: in wait_for_selector
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_page.py:425: in wait_for_selector
    return await self._main_frame.wait_for_selector(**locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:323: in wait_for_selector
    await self._channel.send("waitForSelector", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x104061d00>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.wait_for_selector: Timeout 5000ms exceeded.
E           Call log:
E             - waiting for locator("#rag-search-results .rag-search-result") to be visible

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_______________ test_rag_multiple_source_integration[chromium0] ________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_multiple_source_integration(page: Page, serve_hacka_re):
        """Test RAG integration with multiple knowledge sources (default prompts + user bundles)."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Create default prompts index
        default_prompts_index = {
            "chunks": [
                {
                    "content": "JavaScript is a programming language used for web development.",
                    "embedding": [0.8, 0.1, 0.1, 0.0, 0.0],
                    "metadata": {"type": "default_prompt", "promptName": "JavaScript Basics"},
                    "id": "chunk_js"
                }
            ],
            "metadata": {"totalChunks": 1}
        }
    
        # Create user bundles index
        user_bundles_index = {
            "bundles": [
                {
                    "name": "Python Guide",
                    "chunks": [
                        {
                            "content": "Python is a high-level programming language known for its simplicity.",
                            "embedding": [0.7, 0.2, 0.1, 0.0, 0.0],
                            "metadata": {"type": "user_bundle", "source": "python_guide.md"},
                            "id": "chunk_python"
                        }
                    ],
                    "files": ["python_guide.md"],
                    "metadata": {"model": "text-embedding-3-small"}
                }
            ]
        }
    
        # Store both indexes
        page.evaluate(f"localStorage.setItem('rag_default_prompts_index', '{json.dumps(default_prompts_index)}')")
        page.evaluate(f"localStorage.setItem('rag_user_bundles_index', '{json.dumps(user_bundles_index)}')")
    
        # Test multi-source search
        multi_source_result = page.evaluate("""() => {
            // Test searching for programming-related content
            // This should find results from both default prompts and user bundles
            const query = "programming language";
    
            try {
                // Search in default prompts
                const defaultResults = window.VectorRAGService.search(query, {}, 5);
    
                // Test if we can access user bundles
                const userBundles = window.RAGUserBundles.getBundles();
    
                return {
                    searchCompleted: true,
                    defaultResults: defaultResults ? defaultResults.length : 0,
                    userBundlesAvailable: userBundles ? userBundles.length : 0,
                    multiSourceSetup: defaultResults && userBundles,
                    totalSources: 2 // default prompts + user bundles
                };
            } catch (error) {
                return {
                    searchCompleted: false,
                    error: error.message
                };
            }
        }""")
    
        # Verify multi-source integration
        assert multi_source_result['searchCompleted'], "Multi-source search should complete"
>       assert multi_source_result['defaultResults'] > 0, "Should find results in default prompts"
E       TypeError: '>' not supported between instances of 'NoneType' and 'int'

test_rag_integration.py:613: TypeError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
____________________ test_rag_search_ui_elements[chromium0] ____________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_search_ui_elements(page: Page, serve_hacka_re):
        """Test the RAG search UI elements and basic functionality."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Check search section elements
        search_input = page.locator("#rag-search-input")
        expect(search_input).to_be_visible()
        expect(search_input).to_be_enabled()
    
        search_button = page.locator("#rag-search-btn")
        expect(search_button).to_be_visible()
>       expect(search_button).to_be_enabled()
E       AssertionError: Locator expected to be enabled
E       Actual value: disabled 
E       Call log:
E         - LocatorAssertions.to_be_enabled with timeout 5000ms
E         - waiting for locator("#rag-search-btn")
E           9 √ó locator resolved to <button disabled type="button" id="rag-search-btn" class="btn primary-btn" title="Enter a search query">‚Üµ                                Search‚Üµ         ‚Ä¶</button>
E             - unexpected value "disabled"

test_rag_search.py:28: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
___________________ test_rag_search_without_index[chromium0] ___________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_search_without_index(page: Page, serve_hacka_re):
        """Test search behavior when no index is available."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Clear any existing RAG index
        page.evaluate("localStorage.removeItem('rag_default_prompts_index')")
        page.evaluate("localStorage.removeItem('rag_user_bundles_index')")
    
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Try to perform a search
        search_input = page.locator("#rag-search-input")
        search_button = page.locator("#rag-search-btn")
    
        search_input.fill("test query")
        search_button.click()
    
        # Should show message about no index
>       page.wait_for_selector("#rag-search-results:has-text('No knowledge')", timeout=5000)

test_rag_search.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:8187: in wait_for_selector
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_page.py:425: in wait_for_selector
    return await self._main_frame.wait_for_selector(**locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:323: in wait_for_selector
    await self._channel.send("waitForSelector", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x104a73920>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.wait_for_selector: Timeout 5000ms exceeded.
E           Call log:
E             - waiting for locator("#rag-search-results:has-text('No knowledge')") to be visible

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
__________________ test_rag_search_with_mock_data[chromium0] ___________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_search_with_mock_data(page: Page, serve_hacka_re):
        """Test search functionality with mock indexed data."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Create mock index data in localStorage
        mock_index = {
            "chunks": [
                {
                    "content": "Machine learning is a subset of artificial intelligence that focuses on algorithms.",
                    "embedding": [0.1, 0.2, 0.3, 0.4, 0.5],
                    "metadata": {
                        "promptId": "ml_basics",
                        "promptName": "Machine Learning Basics",
                        "type": "default_prompt"
                    },
                    "id": "chunk_0"
                },
                {
                    "content": "Deep learning uses neural networks with multiple layers to process data.",
                    "embedding": [0.2, 0.3, 0.4, 0.5, 0.6],
                    "metadata": {
                        "promptId": "deep_learning",
                        "promptName": "Deep Learning Introduction",
                        "type": "default_prompt"
                    },
                    "id": "chunk_1"
                }
            ],
            "metadata": {
                "totalChunks": 2,
                "embeddingModel": "text-embedding-3-small",
                "createdAt": "2024-01-01T00:00:00.000Z"
            }
        }
    
        # Store mock index
        page.evaluate(f"localStorage.setItem('rag_default_prompts_index', '{json.dumps(mock_index)}')")
    
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Perform a search
        search_input = page.locator("#rag-search-input")
        search_button = page.locator("#rag-search-btn")
    
        search_input.fill("machine learning")
        search_button.click()
    
        # Wait for results
>       page.wait_for_selector("#rag-search-results .rag-search-result", timeout=5000)

test_rag_search.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:8187: in wait_for_selector
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_page.py:425: in wait_for_selector
    return await self._main_frame.wait_for_selector(**locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:323: in wait_for_selector
    await self._channel.send("waitForSelector", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x104db7600>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.wait_for_selector: Timeout 5000ms exceeded.
E           Call log:
E             - waiting for locator("#rag-search-results .rag-search-result") to be visible

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
______________ test_rag_search_enter_key_functionality[chromium0] ______________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_search_enter_key_functionality(page: Page, serve_hacka_re):
        """Test search using Enter key in the search input."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Create minimal mock index for testing
        mock_index = {
            "chunks": [
                {
                    "content": "Test content for enter key search functionality.",
                    "embedding": [0.1, 0.2, 0.3, 0.4, 0.5],
                    "metadata": {"promptName": "Test Prompt"},
                    "id": "chunk_test"
                }
            ],
            "metadata": {"totalChunks": 1}
        }
    
        page.evaluate(f"localStorage.setItem('rag_default_prompts_index', '{json.dumps(mock_index)}')")
    
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Enter search query and press Enter
        search_input = page.locator("#rag-search-input")
        search_input.fill("test")
        search_input.press("Enter")
    
        # Wait for results
>       page.wait_for_selector("#rag-search-results .rag-search-result", timeout=5000)

test_rag_search.py:312: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:8187: in wait_for_selector
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_page.py:425: in wait_for_selector
    return await self._main_frame.wait_for_selector(**locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:323: in wait_for_selector
    await self._channel.send("waitForSelector", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x104a7fb00>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.wait_for_selector: Timeout 5000ms exceeded.
E           Call log:
E             - waiting for locator("#rag-search-results .rag-search-result") to be visible

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_______________ test_rag_search_empty_query_handling[chromium0] ________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_search_empty_query_handling(page: Page, serve_hacka_re):
        """Test search behavior with empty or whitespace queries."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        search_input = page.locator("#rag-search-input")
        search_button = page.locator("#rag-search-btn")
        results_container = page.locator("#rag-search-results")
    
        # Test empty query
        search_input.fill("")
>       search_button.click()

test_rag_search.py:346: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:15512: in click
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_locator.py:160: in click
    return await self._frame.click(self._selector, strict=True, **params)
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:488: in click
    await self._channel.send("click", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x104a16c00>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Locator.click: Timeout 10000ms exceeded.
E           Call log:
E             - waiting for locator("#rag-search-btn")
E               - locator resolved to <button disabled type="button" id="rag-search-btn" class="btn primary-btn" title="Enter a search query">‚Üµ                                Search‚Üµ         ‚Ä¶</button>
E             - attempting click action
E               2 √ó waiting for element to be visible, enabled and stable
E                 - element is not stable
E               - retrying click action
E               - waiting 20ms
E               2 √ó waiting for element to be visible, enabled and stable
E                 - element is not stable
E               - retrying click action
E                 - waiting 100ms
E               19 √ó waiting for element to be visible, enabled and stable
E                  - element is not enabled
E                - retrying click action
E                  - waiting 500ms

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_________________ test_rag_search_result_formatting[chromium0] _________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_search_result_formatting(page: Page, serve_hacka_re):
        """Test the formatting and display of search results."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Create detailed mock index for result formatting test
        mock_index = {
            "chunks": [
                {
                    "content": "This is a comprehensive guide to machine learning algorithms and their applications in modern data science. It covers supervised learning, unsupervised learning, and reinforcement learning techniques.",
                    "embedding": [0.8, 0.2, 0.1, 0.1, 0.1],
                    "metadata": {
                        "promptId": "ml_guide",
                        "promptName": "Complete Machine Learning Guide",
                        "type": "default_prompt",
                        "chunkIndex": 0
                    },
                    "id": "chunk_detailed"
                }
            ],
            "metadata": {"totalChunks": 1}
        }
    
        page.evaluate(f"localStorage.setItem('rag_default_prompts_index', '{json.dumps(mock_index)}')")
    
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Perform search
        search_input = page.locator("#rag-search-input")
        search_input.fill("machine learning")
        search_input.press("Enter")
    
        # Wait for results
>       page.wait_for_selector("#rag-search-results .rag-search-result", timeout=5000)

test_rag_search.py:413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:8187: in wait_for_selector
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_page.py:425: in wait_for_selector
    return await self._main_frame.wait_for_selector(**locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:323: in wait_for_selector
    await self._channel.send("waitForSelector", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x104a52b60>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.wait_for_selector: Timeout 5000ms exceeded.
E           Call log:
E             - waiting for locator("#rag-search-results .rag-search-result") to be visible

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_______________ test_rag_search_with_real_embeddings[chromium0] ________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_rag_search_with_real_embeddings(page: Page, serve_hacka_re, api_key):
        """Test that RAG search works with real pre-cached embeddings and API key for query."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Configure API key for query embedding generation
        page.evaluate(f"localStorage.setItem('openai_api_key', '{api_key}')")
        page.evaluate("localStorage.setItem('base_url', 'https://api.openai.com/v1')")
        page.evaluate("localStorage.setItem('selected_model', 'gpt-4o-mini')")
    
        # Wait for initialization
        page.wait_for_timeout(2000)
    
        # Verify pre-cached embeddings are loaded
        embeddings_info = page.evaluate("""() => {
            const stats = {
                hasVectorStore: !!window.ragVectorStore,
                hasVectorService: !!window.VectorRAGService,
                documentCount: 0,
                totalVectors: 0,
                documents: []
            };
    
            if (window.ragVectorStore) {
                const docIds = window.ragVectorStore.getDocumentIds();
                stats.documentCount = docIds.length;
    
                docIds.forEach(id => {
                    const vectors = window.ragVectorStore.getVectors(id);
                    if (vectors) {
                        stats.totalVectors += vectors.length;
                        stats.documents.push({
                            id: id,
                            vectorCount: vectors.length,
                            hasEmbeddings: vectors.length > 0 && vectors[0].embedding && vectors[0].embedding.length > 0,
                            embeddingDims: vectors[0].embedding ? vectors[0].embedding.length : 0
                        });
                    }
                });
            }
    
            return stats;
        }""")
    
        print(f"Pre-cached embeddings info: {embeddings_info}")
>       assert embeddings_info['totalVectors'] == 150, f"Expected 150 vectors, got {embeddings_info['totalVectors']}"
E       AssertionError: Expected 150 vectors, got 590
E       assert 590 == 150

test_rag_with_precached.py:59: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Pre-cached embeddings info: {'hasVectorStore': True, 'hasVectorService': True, 'documentCount': 3, 'totalVectors': 590, 'documents': [{'id': 'aia', 'vectorCount': 154, 'hasEmbeddings': True, 'embeddingDims': 1536}, {'id': 'cra', 'vectorCount': 232, 'hasEmbeddings': True, 'embeddingDims': 1536}, {'id': 'dora', 'vectorCount': 204, 'hasEmbeddings': True, 'embeddingDims': 1536}]}
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
____________________ test_context_window_scaling[chromium1] ____________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_context_window_scaling(page: Page, serve_hacka_re):
        """Test that the context window meter scales with the model's context size."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=2000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Enter the API key
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(API_KEY)
    
        # Select OpenAI as the API provider
        base_url_select = page.locator("#base-url-select")
        base_url_select.select_option("openai")
    
        # Click the reload models button
        reload_button = page.locator("#model-reload-btn")
        reload_button.click()
    
        # Wait for the models to be loaded
        # First, check if the model select has any non-disabled options
        try:
            page.wait_for_selector("#model-select option:not([disabled])", state="visible", timeout=2000)
            print("Models loaded successfully")
        except Exception as e:
            print(f"Error waiting for models to load: {e}")
            # Force a longer wait time
            time.sleep(0.5)
    
            # Check if there are any options in the model select
            options_count = page.evaluate("""() => {
                const select = document.getElementById('model-select');
                if (!select) return 0;
                return Array.from(select.options).filter(opt => !opt.disabled).length;
            }""")
            print(f"Found {options_count} non-disabled options in model select")
    
            if options_count == 0:
                # Try clicking the reload button again
                print("No options found, clicking reload button again")
>               reload_button.click()

test_context_window_scaling.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:15512: in click
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_locator.py:160: in click
    return await self._frame.click(self._selector, strict=True, **params)
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:488: in click
    await self._channel.send("click", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x103ec6ac0>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Locator.click: Timeout 10000ms exceeded.
E           Call log:
E             - waiting for locator("#model-reload-btn")
E               - locator resolved to <button disabled type="button" class="icon-btn" id="model-reload-btn" title="Reload models from API">‚Ä¶</button>
E             - attempting click action
E               2 √ó waiting for element to be visible, enabled and stable
E                 - element is not enabled
E               - retrying click action
E               - waiting 20ms
E               2 √ó waiting for element to be visible, enabled and stable
E                 - element is not enabled
E               - retrying click action
E                 - waiting 100ms
E               19 √ó waiting for element to be visible, enabled and stable
E                  - element is not enabled
E                - retrying click action
E                  - waiting 500ms

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Error waiting for models to load: Page.wait_for_selector: Timeout 2000ms exceeded.
Call log:
  - waiting for locator("#model-select option:not([disabled])") to be visible

Found 0 non-disabled options in model select
No options found, clicking reload button again
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
__________________ test_debug_mode_checkbox_exists[chromium1] __________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_debug_mode_checkbox_exists(page, serve_hacka_re):
        """Test that the debug mode checkbox exists in the settings modal."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        from test_utils import dismiss_welcome_modal
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Open settings modal
        page.click("#settings-btn")
    
        # Wait for settings modal to be visible
        expect(page.locator("#settings-modal")).to_be_visible()
    
        # Scroll to the system prompt section to ensure the debug checkbox is in view
        page.locator("#open-prompts-config").scroll_into_view_if_needed()
    
        # Wait for debug mode checkbox to be added dynamically
        debug_checkbox = page.locator("#debug-mode")
        debug_checkbox.wait_for(state="visible", timeout=2000)
    
        # Check if the label text is correct
        debug_label = page.locator("label[for='debug-mode']")
        expect(debug_label).to_be_visible()
>       expect(debug_label).to_have_text("Debug mode")
E       AssertionError: Locator expected to have text 'Debug mode'
E       Actual value: Debug mode(Disabled) 
E       Call log:
E         - LocatorAssertions.to_have_text with timeout 5000ms
E         - waiting for locator("label[for='debug-mode']")
E           9 √ó locator resolved to <label for="debug-mode">‚Ä¶</label>
E             - unexpected value "Debug mode(Disabled)"

test_debug_mode.py:30: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
___________________ test_default_prompts_content[chromium1] ____________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_default_prompts_content(page, serve_hacka_re):
        """Test that the default prompts section contains the expected content."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if present
        # Wait a moment for the page to fully load
        # page.wait_for_timeout(500)  # TODO: Replace with proper wait condition
    
        # Click the prompts button
        prompts_button = page.locator("#prompts-btn")
        prompts_button.click()
    
        # Check that the prompts modal is visible
        prompts_modal = page.locator("#prompts-modal")
        expect(prompts_modal).to_be_visible()
    
        # Click the default prompts header to expand
        default_prompts_header = page.locator(".default-prompts-header")
        default_prompts_header.click()
    
        # Check that the default prompts list is now visible (expanded)
        default_prompts_list = page.locator(".default-prompts-list")
        expect(default_prompts_list).to_be_visible()
    
        # Check that there are at least one default prompt item
        default_prompt_items = page.locator(".default-prompt-item")
        count = default_prompt_items.count()
        assert count >= 1, f"Expected at least 1 default prompt item, but found {count}"
    
        # Check that one of the default prompts is about the hacka.re project
        hacka_re_prompt = page.locator(".default-prompt-item:has-text('About hacka.re Project')")
>       expect(hacka_re_prompt).to_be_visible()
E       AssertionError: Locator expected to be visible
E       Actual value: <element(s) not found> 
E       Call log:
E         - LocatorAssertions.to_be_visible with timeout 5000ms
E         - waiting for locator(".default-prompt-item:has-text('About hacka.re Project')")

test_default_prompts.py:137: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
__________________ test_default_prompts_selection[chromium1] ___________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_default_prompts_selection(page, serve_hacka_re):
        """Test that default prompts can be selected and deselected."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if present
        # Wait a moment for the page to fully load
        # page.wait_for_timeout(500)  # TODO: Replace with proper wait condition
    
        # Click the prompts button
        prompts_button = page.locator("#prompts-btn")
        prompts_button.click()
    
        # Check that the prompts modal is visible
        prompts_modal = page.locator("#prompts-modal")
        expect(prompts_modal).to_be_visible()
    
        # Click the default prompts header to expand
        default_prompts_header = page.locator(".default-prompts-header")
        default_prompts_header.click()
    
        # Check that the default prompts list is now visible (expanded)
        default_prompts_list = page.locator(".default-prompts-list")
        expect(default_prompts_list).to_be_visible()
    
        # Define the prompts to test
        prompts_to_test = [
            ".default-prompt-item:has-text('About hacka.re Project')",
            ".default-prompt-item:has-text('OWASP Top 10 for LLM Applications')"
        ]
    
        # Test each prompt
        for prompt_selector in prompts_to_test:
            # Find the prompt
            prompt = page.locator(prompt_selector)
>           expect(prompt).to_be_visible()
E           AssertionError: Locator expected to be visible
E           Actual value: <element(s) not found> 
E           Call log:
E             - LocatorAssertions.to_be_visible with timeout 5000ms
E             - waiting for locator(".default-prompt-item:has-text('About hacka.re Project')")

test_default_prompts.py:197: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
__________________ test_function_collection_colors[chromium1] __________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_function_collection_colors(page: Page, serve_hacka_re, api_key):
        """Test that functions from the same import are collected by color and deletion works for the entire collection."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_group_colors.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
____________________ test_function_calling_icons[chromium1] ____________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_function_calling_icons(page: Page, serve_hacka_re, api_key):
        """Test that function calling icons appear inline with the token stream."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_icons.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
________________ test_multiple_function_calls_colors[chromium1] ________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_multiple_function_calls_colors(page: Page, serve_hacka_re, api_key):
        """Test that multiple function calls use different colors."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_icons.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
____________________ test_function_library_multi[chromium1] ____________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_function_library_multi(page: Page, serve_hacka_re, api_key):
        """Test the multi-function library with @tool tag."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_library_multi.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
___________________ test_function_library_sharing[chromium1] ___________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_function_library_sharing(page: Page, serve_hacka_re):
        """
        Test that function library can be shared and loaded from a shared link.
    
        This test:
        1. Creates a test function
        2. Shares it using the function library option
        3. Deletes the function
        4. Loads the shared link
        5. Verifies the function is restored
        """
        # STEP 1: Navigate to the application
        page.goto(serve_hacka_re)
    
        # STEP 2: Handle welcome and settings modals
        dismiss_welcome_modal(page)
        # STEP 3: Configure API key and model
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click()
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible")
    
        # Enter the API key
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(API_KEY)
    
        # Select OpenAI as the API provider
        base_url_select = page.locator("#base-url-select")
        base_url_select.select_option("openai")
    
        # Select a model
        from test_utils import select_recommended_test_model
        selected_model = select_recommended_test_model(page)
    
        # Settings auto-save, wait and close
        page.wait_for_timeout(1000)
        close_button = page.locator("#close-settings")
        close_button.click()
    
        # Wait for the settings modal to be closed
        page.wait_for_selector("#settings-modal", state="hidden")
    
        # STEP 4: Create a test function
        # Open the function modal
        function_btn = page.locator("#function-btn")
        function_btn.click()
    
        # Wait for the function modal to be visible
        function_modal = page.locator("#function-modal")
        expect(function_modal).to_be_visible()
    
        # First, set the function code - the name field will be auto-populated
        function_name = "test_shared_function"
        function_code = f"""function {function_name}(text) {{
      return {{
        message: "You said: " + text,
        timestamp: new Date().toISOString()
      }};
    }}"""
    
        function_code_input = page.locator("#function-code")
        function_code_input.scroll_into_view_if_needed()
        expect(function_code_input).to_be_visible()
        function_code_input.fill(function_code)
    
        # Trigger the auto-population by firing an input event
        page.evaluate("""() => {
            const codeTextarea = document.getElementById('function-code');
            if (codeTextarea) {
                codeTextarea.dispatchEvent(new Event('input', { bubbles: true }));
            }
        }""")
    
        # Wait a moment for auto-population to happen
        # page.wait_for_timeout(500)  # TODO: Replace with proper wait condition
    
        # Verify the function name field was auto-populated
        name_value = page.evaluate("""() => {
            const nameField = document.getElementById('function-name');
            return nameField ? nameField.value : null;
        }""")
    
        if name_value:
            assert name_value == function_name, f"Expected '{function_name}', got '{name_value}'"
    
        # Validate the function
        validate_btn = page.locator("#function-validate-btn")
        validate_btn.scroll_into_view_if_needed()
        expect(validate_btn).to_be_visible()
        validate_btn.click()
    
        # Wait for validation result
        validation_result = page.locator("#function-validation-result")
        page.wait_for_selector("#function-validation-result:not(:empty)", state="visible")
        expect(validation_result).to_contain_text("Library validated successfully")
    
        # Save the function
        save_btn = page.locator("#function-editor-form button[type='submit']")
        save_btn.scroll_into_view_if_needed()
        expect(save_btn).to_be_visible()
        save_btn.click()
    
        # Verify the function was added to the list
        function_list = page.locator("#function-list")
        page.wait_for_selector(f".function-item-name:has-text('{function_name}')", state="visible")
        expect(function_list.locator(f".function-item-name:has-text('{function_name}')")).to_be_visible()
    
        # Take a screenshot after adding the function
        screenshot_with_markdown(page, "function_library_sharing_function_added", {
            "step": "Added test function for sharing",
            "function_name": function_name
        })
    
        # Close the function modal
        close_function_modal_btn = page.locator("#close-function-modal")
        close_function_modal_btn.click()
    
        # STEP 5: Share the function library
        # Open the share modal
        share_btn = page.locator("#share-btn")
        share_btn.click()
    
        # Wait for the share modal to be visible
        share_modal = page.locator("#share-modal")
        expect(share_modal).to_be_visible()
    
        # Set a test password
        test_password = "TestPassword123"
        password_input = page.locator("#share-password")
        password_input.fill(test_password)
    
        # Check the function library checkbox
        function_library_checkbox = page.locator("#share-function-library")
        function_library_checkbox.check()
    
        # Also check API key checkbox to ensure we have something to share
        api_key_checkbox = page.locator("#share-api-key")
        api_key_checkbox.check()
    
        # Take a screenshot of the share modal
        screenshot_with_markdown(page, "function_library_sharing_share_modal", {
            "step": "Share modal with function library option checked",
            "password": test_password,
            "function_library_checked": function_library_checkbox.is_checked(),
            "api_key_checked": api_key_checkbox.is_checked()
        })
    
        # Generate the share link
        generate_link_btn = page.locator("#generate-share-link-btn")
        generate_link_btn.click()
    
        # Wait a moment for the link generation process
        # page.wait_for_timeout(1000)  # TODO: Replace with proper wait condition
    
        # Take a screenshot after clicking generate button
        screenshot_with_markdown(page, "function_library_sharing_after_generate", {
            "step": "After clicking generate link button",
            "container_visible": page.locator("#generated-link-container").is_visible()
        })
    
        # Wait for the link to be generated
        generated_link_container = page.locator("#generated-link-container")
        expect(generated_link_container).to_be_visible()
    
        # Get the generated link
        generated_link = page.locator("#generated-link").input_value()
    
        # Validate the link is not empty and has the expected format
        assert generated_link, "Generated link is empty"
        assert "#gpt=" in generated_link, f"Generated link doesn't contain #gpt= fragment: {generated_link}"
    
        # Take a screenshot of the generated link
        screenshot_with_markdown(page, "function_library_sharing_generated_link", {
            "step": "Generated share link",
            "link_length": len(generated_link),
            "link_preview": generated_link[:100] + "..." if len(generated_link) > 100 else generated_link,
            "has_gpt_fragment": "#gpt=" in generated_link
        })
    
        # Close the share modal
        close_share_modal_btn = page.locator("#close-share-modal")
        close_share_modal_btn.click()
    
        # STEP 6: Delete the function
        # Open the function modal again
        function_btn.click()
        expect(function_modal).to_be_visible()
    
        # Delete the function
        # Handle the confirmation dialog
        page.on("dialog", lambda dialog: dialog.accept())
    
        # Find and click the delete button for the function
        # The delete button is in the same function-item div as the function name
        function_item = page.locator(f"#function-list .function-item").filter(has=page.locator(f".function-item-name:has-text('{function_name}')"))
        delete_btn = function_item.locator(".function-item-delete")
>       delete_btn.click()

test_function_library_sharing.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:15512: in click
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_locator.py:160: in click
    return await self._frame.click(self._selector, strict=True, **params)
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:488: in click
    await self._channel.send("click", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x103e1f060>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Locator.click: Timeout 10000ms exceeded.
E           Call log:
E             - waiting for locator("#function-list .function-item").filter(has=locator(".function-item-name:has-text('test_shared_function')")).locator(".function-item-delete")

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Available options in model select dropdown:
  Option: -- Default models (API unavailable) -- (value: , disabled: True)
  Option: üá∫üá∏ Gpt 4o Mini (value: gpt-4o-mini, disabled: False)
  Option: üá∫üá∏ Gpt 4o (value: gpt-4o, disabled: False)
  Option: üá∫üá∏ Gpt 4 Turbo (value: gpt-4-turbo, disabled: False)
  Option: üá∫üá∏ Gpt 3.5 Turbo (value: gpt-3.5-turbo, disabled: False)
Recommended model not available. Selecting first option: gpt-4o-mini
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
______________ test_all_functions_callable_by_default[chromium1] _______________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_all_functions_callable_by_default(page: Page, serve_hacka_re, api_key):
        """Test that all functions are callable by default when no tags are present."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_parsing_logic.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
________________ test_only_tagged_functions_callable[chromium1] ________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_only_tagged_functions_callable(page: Page, serve_hacka_re, api_key):
        """Test that only tagged functions are callable when at least one tag is present."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_parsing_logic.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
________________________ test_tool_tag_works[chromium1] ________________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_tool_tag_works(page: Page, serve_hacka_re, api_key):
        """Test that the @tool tag works the same as @callable."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_parsing_logic.py:272: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
___________________ test_single_line_comment_tags[chromium1] ___________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_single_line_comment_tags(page: Page, serve_hacka_re, api_key):
        """Test that single-line comment tags work."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_parsing_logic.py:395: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_______________________ test_mixed_tag_types[chromium1] ________________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_mixed_tag_types(page: Page, serve_hacka_re, api_key):
        """Test that mixed tag types work together."""
        # Set up console error logging
        setup_console_logging(page)
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Configure API key and model
>       configure_api_key_and_model(page, api_key)

test_function_parsing_logic.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

page = <Page url='http://localhost:8000/'>
api_key = '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'

    def configure_api_key_and_model(page, api_key):
        """Configure API key and select a function calling model."""
        print("Configuring API key and model...")
    
        # Click the settings button
        settings_button = page.locator("#settings-btn")
        settings_button.click(timeout=1000)
    
        # Wait for the settings modal to become visible
        page.wait_for_selector("#settings-modal.active", state="visible", timeout=2000)
    
        # Take a screenshot of the settings modal for debugging
        page.screenshot(path="_tests/playwright/videos/settings_modal_initial.png")
    
        # Enter the API key from .env
        api_key_input = page.locator("#api-key-update")
        api_key_input.fill(api_key)
    
        # Get OPENAI_API_BASE and OPENAI_API_MODEL from conftest.py
        import sys
        import os
        # Add the parent directory (playwright) to path to import from main conftest
        playwright_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
        if playwright_dir not in sys.path:
            sys.path.insert(0, playwright_dir)
>       from conftest import OPENAI_API_BASE, OPENAI_API_MODEL
E       ImportError: cannot import name 'OPENAI_API_BASE' from 'conftest' (/Users/user/dev/hacka.re/_tests/playwright/shodan/conftest.py)

function_calling_api/helpers/setup_helpers.py:49: ImportError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Configuring API key and model...
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_________________ test_input_field_scroll_behavior[chromium1] __________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_input_field_scroll_behavior(page: Page, serve_hacka_re):
        """Test that focusing the input field doesn't scroll past the footer."""
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if present
        # Take a screenshot of the initial state
        screenshot_with_markdown(page, "input_field_scroll_initial.png", {
            "Status": "Initial page load",
            "Test": "Input field scroll behavior",
            "Description": "Checking that input field focus doesn't scroll past the footer"
        })
    
        # Get the footer element for position reference
        footer = page.locator("footer")
>       expect(footer).to_be_visible()
E       AssertionError: Locator expected to be visible
E       Actual value: <element(s) not found> 
E       Call log:
E         - LocatorAssertions.to_be_visible with timeout 5000ms
E         - waiting for locator("footer")

test_input_field_scroll.py:23: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_____________ test_input_field_scroll_safari_emulation[chromium1] ______________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_input_field_scroll_safari_emulation(page: Page, serve_hacka_re):
        """Test input field scroll behavior with Safari emulation."""
        # Configure the context to emulate Safari on iOS
        page.context.add_cookies([{
            "name": "safari-emulation",
            "value": "true",
            "url": serve_hacka_re,
        }])
    
        # Set Safari user agent
        page.set_extra_http_headers({
            "User-Agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1"
        })
    
        # Navigate to the page
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if present
        # Take a screenshot of the initial state with Safari emulation
        screenshot_with_markdown(page, "safari_input_field_scroll_initial.png", {
            "Status": "Initial page load with Safari emulation",
            "Test": "Safari input field scroll behavior",
            "Description": "Checking that input field focus doesn't scroll past the footer in Safari"
        })
    
        # Get the footer element for position reference
        footer = page.locator("footer")
>       expect(footer).to_be_visible()
E       AssertionError: Locator expected to be visible
E       Actual value: <element(s) not found> 
E       Call log:
E         - LocatorAssertions.to_be_visible with timeout 5000ms
E         - waiting for locator("footer")

test_input_field_scroll.py:105: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
______________________ test_heart_logo_tooltip[chromium1] ______________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_heart_logo_tooltip(page: Page, serve_hacka_re):
        """Test that the heart logo modal appears when clicking on various elements."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if present
        # Take a screenshot of the initial state
        screenshot_with_markdown(page, "heart_logo_tooltip_initial", {
            "Status": "Initial state before clicking",
            "Component": "Heart Logo Modal"
        })
    
        # Check that the logo info modal is initially hidden
        logo_modal = page.locator("#logo-info-modal")
        expect(logo_modal).not_to_be_visible()
    
        # Test clicking on the heart logo
        heart_logo = page.locator(".heart-logo")
        expect(heart_logo).to_be_visible()
    
        # Click on the heart logo
        heart_logo.click()
    
        # Check that the modal is now visible
>       expect(logo_modal).to_be_visible()
E       AssertionError: Locator expected to be visible
E       Actual value: <element(s) not found> 
E       Call log:
E         - LocatorAssertions.to_be_visible with timeout 5000ms
E         - waiting for locator("#logo-info-modal")

test_logo_tooltip.py:32: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
____________________ test_context_window_display[chromium1] ____________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_context_window_display(page: Page, serve_hacka_re, api_key):
        """Test that context window is displayed in the UI"""
    
        # Navigate to the page
        page.goto(serve_hacka_re)
        dismiss_welcome_modal(page)
    
        # Dismiss settings modal if already open
        # Open settings
        settings_btn = page.locator("#settings-btn")
        settings_btn.click()
        page.wait_for_selector("#settings-modal", state="visible")
    
        # Configure OpenAI API
        api_key_input = page.locator("#api-key-input")
>       api_key_input.fill(api_key)

test_models_context_simple.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:15851: in fill
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_locator.py:212: in fill
    return await self._frame.fill(self._selector, strict=True, **params)
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x103ec6700>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Locator.fill: Timeout 10000ms exceeded.
E           Call log:
E             - waiting for locator("#api-key-input")

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_______________ test_function_library_default_prompt[chromium1] ________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_function_library_default_prompt(page: Page, serve_hacka_re):
        """Test that the 'Function library' default prompt is available and works correctly."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Check if settings modal is already open and dismiss it
        settings_modal = page.locator("#settings-modal")
        if settings_modal.is_visible():
            print("Settings modal is already open, dismissing it first")
            # Wait a moment to ensure the modal is fully closed
            time.sleep(0.5)
    
        # Take a screenshot at the start
        screenshot_with_markdown(page, "function_library_prompt_test_start.png", {
            "Status": "Test started",
            "Test Name": "Function Library Default Prompt",
            "Description": "Verifying that the Function Library default prompt exists and works correctly"
        })
    
        # First, create a function in the function library
        page.locator("#function-btn").click()
    
        # Wait for the function modal to be visible
        function_modal = page.locator("#function-modal")
        expect(function_modal).to_be_visible()
    
        # Fill in the function code
        function_code = """
    /**
     * A test function for the function library prompt
     * @description This is a test function
     * @param {string} input - Input string
     * @returns {Object} Result object
     */
    function test_function(input) {
      return {
        result: `Processed: ${input}`,
        timestamp: new Date().toISOString()
      };
    }
    """
        page.locator("#function-code").fill(function_code)
    
        # Save the function
        page.locator("#function-editor-form button[type='submit']").click()
    
        # Wait for the function to be saved
        page.wait_for_timeout(1000)
    
        # Take a screenshot after creating the function
        screenshot_with_markdown(page, "function_created.png", {
            "Status": "Function created",
            "Function Name": "test_function",
            "Test Name": "Function Library Default Prompt"
        })
    
        # Close the function modal
        page.locator("#close-function-modal").click()
        expect(function_modal).not_to_be_visible()
    
        # Reload the page to ensure the function is properly saved and loaded
        page.reload()
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Check if settings modal is already open and dismiss it
        settings_modal = page.locator("#settings-modal")
        if settings_modal.is_visible():
            print("Settings modal is already open after reload, dismissing it")
            # Wait a moment to ensure the modal is fully closed
            time.sleep(0.5)
    
        # Open the prompts modal
        page.locator("#prompts-btn").click()
    
        # Check that the prompts modal is visible
        prompts_modal = page.locator("#prompts-modal")
        expect(prompts_modal).to_be_visible()
    
        # Expand the default prompts section
        page.locator(".default-prompts-header").click()
    
        # Wait for the default prompts list to be visible
        default_prompts_list = page.locator(".default-prompts-list")
        expect(default_prompts_list).to_be_visible()
    
        # Check if the Code section exists and expand it if it does
        code_section = page.locator(".nested-section-header:has-text('Code')")
        if code_section.count() > 0:
            print("Found Code section, expanding it")
            code_section.click()
    
            # Wait for the nested section list to be visible
            nested_list = page.locator(".nested-section-list")
            expect(nested_list).to_be_visible()
    
        # Check if the "Function Library" prompt exists
        function_library_prompt = page.locator(".default-prompt-item:has-text('Function library')")
>       expect(function_library_prompt).to_be_visible()
E       AssertionError: Locator expected to be visible
E       Actual value: <element(s) not found> 
E       Call log:
E         - LocatorAssertions.to_be_visible with timeout 5000ms
E         - waiting for locator(".default-prompt-item:has-text('Function library')")

test_prompt_order_and_function_library_prompt.py:194: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_________________ test_rag_user_bundles_ui_elements[chromium1] _________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_user_bundles_ui_elements(page: Page, serve_hacka_re):
        """Test the user bundles UI elements and basic functionality."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Check user bundles section elements
        user_bundles_section = page.locator("#rag-user-bundles-section")
>       expect(user_bundles_section).to_be_visible()
E       AssertionError: Locator expected to be visible
E       Actual value: <element(s) not found> 
E       Call log:
E         - LocatorAssertions.to_be_visible with timeout 5000ms
E         - waiting for locator("#rag-user-bundles-section")

test_rag_bundles.py:25: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
______________ test_rag_bundle_load_button_interaction[chromium1] ______________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_bundle_load_button_interaction(page: Page, serve_hacka_re):
        """Test the load bundle button interaction."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Check load bundle button
        load_bundle_btn = page.locator("#load-user-bundle-btn")
>       expect(load_bundle_btn).to_be_visible()
E       AssertionError: Locator expected to be visible
E       Actual value: <element(s) not found> 
E       Call log:
E         - LocatorAssertions.to_be_visible with timeout 5000ms
E         - waiting for locator("#load-user-bundle-btn")

test_rag_bundles.py:362: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_________________ test_rag_embedding_generation_ui[chromium1] __________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_rag_embedding_generation_ui(page: Page, serve_hacka_re, api_key):
        """Test the RAG embedding generation UI and progress indicators."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Configure API key first
        page.evaluate(f"localStorage.setItem('openai_api_key', '{api_key}')")
        page.evaluate("localStorage.setItem('base_url', 'https://api.openai.com/v1')")
        page.evaluate("localStorage.setItem('selected_model', 'gpt-4o-mini')")
    
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Check initial state of embedding generation section
        generate_btn = page.locator("#generate-default-prompts-embeddings")
>       expect(generate_btn).to_be_visible()
E       AssertionError: Locator expected to be visible
E       Actual value: <element(s) not found> 
E       Call log:
E         - LocatorAssertions.to_be_visible with timeout 5000ms
E         - waiting for locator("#generate-default-prompts-embeddings")

test_rag_indexing.py:28: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_______________ test_rag_embedding_generation_process[chromium1] _______________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_rag_embedding_generation_process(page: Page, serve_hacka_re, api_key):
        """Test the actual embedding generation process with real API calls."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Configure API key and settings
        page.evaluate(f"localStorage.setItem('openai_api_key', '{api_key}')")
        page.evaluate("localStorage.setItem('base_url', 'https://api.openai.com/v1')")
        page.evaluate("localStorage.setItem('selected_model', 'gpt-4o-mini')")
    
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Click generate embeddings button
        generate_btn = page.locator("#generate-default-prompts-embeddings")
>       generate_btn.click()

test_rag_indexing.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:15512: in click
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_locator.py:160: in click
    return await self._frame.click(self._selector, strict=True, **params)
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:488: in click
    await self._channel.send("click", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x104a71260>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Locator.click: Timeout 10000ms exceeded.
E           Call log:
E             - waiting for locator("#generate-default-prompts-embeddings")

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
___________ test_rag_embedding_generation_without_api_key[chromium1] ___________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_embedding_generation_without_api_key(page: Page, serve_hacka_re):
        """Test embedding generation behavior without API key."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Ensure no API key is set
        page.evaluate("localStorage.removeItem('openai_api_key')")
    
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Try to click generate embeddings button
        generate_btn = page.locator("#generate-default-prompts-embeddings")
>       generate_btn.click()

test_rag_indexing.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:15512: in click
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_locator.py:160: in click
    return await self._frame.click(self._selector, strict=True, **params)
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:488: in click
    await self._channel.send("click", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x10417da80>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Locator.click: Timeout 10000ms exceeded.
E           Call log:
E             - waiting for locator("#generate-default-prompts-embeddings")

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
__________________ test_rag_enhanced_chat_response[chromium1] __________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_rag_enhanced_chat_response(page: Page, serve_hacka_re, api_key):
        """Test that chat responses are enhanced with RAG context and verify content inclusion."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Configure API key and settings
        page.evaluate(f"localStorage.setItem('openai_api_key', '{api_key}')")
        page.evaluate("localStorage.setItem('base_url', 'https://api.openai.com/v1')")
        page.evaluate("localStorage.setItem('selected_model', 'gpt-4o-mini')")
    
        # Enable debug mode and RAG category to capture debug logs
        page.evaluate("""
            window.DebugService.setDebugMode(true);
            window.DebugService.setCategoryEnabled('rag', true);
        """)
    
        # Create comprehensive mock RAG index with very specific content that should be identifiable in responses
        specific_rag_index = {
            "chunks": [
                {
                    "content": "UNIQUE_RAG_MARKER: Test-driven development (TDD) follows the Red-Green-Refactor cycle: write a failing test (Red), write minimal code to make it pass (Green), then improve the code structure (Refactor). This approach ensures high code quality and comprehensive test coverage.",
                    "embedding": [0.9, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                    "metadata": {
                        "promptId": "tdd_process",
                        "promptName": "Test-Driven Development Process",
                        "type": "default_prompt"
                    },
                    "id": "chunk_tdd_specific"
                }
            ],
            "metadata": {
                "totalChunks": 1,
                "embeddingModel": "text-embedding-3-small"
            }
        }
    
        # Store mock index
        page.evaluate(f"localStorage.setItem('rag_default_prompts_index', '{json.dumps(specific_rag_index)}')")
    
        # Send a chat message that should match our specific RAG content
        chat_input = page.locator("#chat-input")
        send_button = page.locator("#send-btn")
    
        # Type a question that should trigger our specific RAG content
        test_question = "What is test-driven development and how does it work?"
>       chat_input.fill(test_question)

test_rag_integration.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:15851: in fill
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_locator.py:212: in fill
    return await self._frame.fill(self._selector, strict=True, **params)
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x104a51620>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Locator.fill: Timeout 10000ms exceeded.
E           Call log:
E             - waiting for locator("#chat-input")

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_______________ test_rag_context_injection_mechanism[chromium1] ________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_context_injection_mechanism(page: Page, serve_hacka_re):
        """Test the RAG context injection mechanism without making API calls."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Create mock RAG index
        mock_index = {
            "chunks": [
                {
                    "content": "Context about web development: HTML, CSS, and JavaScript are the core technologies for building web applications.",
                    "embedding": [0.8, 0.2, 0.0, 0.0, 0.0],
                    "metadata": {"promptName": "Web Development Basics"},
                    "id": "chunk_web_dev"
                }
            ],
            "metadata": {"totalChunks": 1}
        }
    
        page.evaluate(f"localStorage.setItem('rag_default_prompts_index', '{json.dumps(mock_index)}')")
    
        # Test context injection through browser console
        context_injection_result = page.evaluate("""() => {
            // Mock a user message about web development
            const userMessage = "How do I build a website?";
    
            // Test if we can perform RAG search
            try {
                const searchResults = window.VectorRAGService.search(userMessage, {}, 1);
    
                // Check if context formatting works
                if (searchResults && searchResults.length > 0) {
                    const formattedContext = window.VectorRAGService.formatResultsForContext(searchResults);
    
                    return {
                        searchPerformed: true,
                        resultsFound: searchResults.length > 0,
                        contextFormatted: formattedContext && formattedContext.length > 0,
                        contextContent: formattedContext,
                        searchResults: searchResults
                    };
                }
    
                return {
                    searchPerformed: true,
                    resultsFound: false,
                    contextFormatted: false
                };
            } catch (error) {
                return {
                    searchPerformed: false,
                    error: error.message
                };
            }
        }""")
    
        # Verify context injection mechanism
        assert context_injection_result['searchPerformed'], "RAG search should be performed"
>       assert context_injection_result['resultsFound'], "Relevant results should be found"
E       AssertionError: Relevant results should be found
E       assert False

test_rag_integration.py:289: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
___________________ test_rag_end_to_end_workflow[chromium1] ____________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_rag_end_to_end_workflow(page: Page, serve_hacka_re, api_key):
        """Test complete end-to-end RAG workflow from indexing to chat response."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Configure API key and settings
        page.evaluate(f"localStorage.setItem('openai_api_key', '{api_key}')")
        page.evaluate("localStorage.setItem('base_url', 'https://api.openai.com/v1')")
        page.evaluate("localStorage.setItem('selected_model', 'gpt-4o-mini')")
    
        # Step 1: Create and store a knowledge base
        mock_knowledge_base = {
            "chunks": [
                {
                    "content": "Test-driven development (TDD) is a software development approach where tests are written before the actual code. The cycle involves writing a failing test, writing minimal code to pass the test, and then refactoring.",
                    "embedding": [0.9, 0.1, 0.0, 0.0, 0.0],
                    "metadata": {
                        "promptId": "tdd_guide",
                        "promptName": "Test-Driven Development Guide",
                        "type": "default_prompt"
                    },
                    "id": "chunk_tdd"
                }
            ],
            "metadata": {"totalChunks": 1, "embeddingModel": "text-embedding-3-small"}
        }
    
        page.evaluate(f"localStorage.setItem('rag_default_prompts_index', '{json.dumps(mock_knowledge_base)}')")
    
        # Step 2: Open RAG modal and verify search functionality
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Test search in RAG modal
        search_input = page.locator("#rag-search-input")
        search_button = page.locator("#rag-search-btn")
    
        search_input.fill("test driven development")
        search_button.click()
    
        # Wait for and verify search results
>       page.wait_for_selector("#rag-search-results .rag-search-result", timeout=5000)

test_rag_integration.py:408: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:8187: in wait_for_selector
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_page.py:425: in wait_for_selector
    return await self._main_frame.wait_for_selector(**locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:323: in wait_for_selector
    await self._channel.send("waitForSelector", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x10417e8e0>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.wait_for_selector: Timeout 5000ms exceeded.
E           Call log:
E             - waiting for locator("#rag-search-results .rag-search-result") to be visible

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_______________ test_rag_multiple_source_integration[chromium1] ________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_multiple_source_integration(page: Page, serve_hacka_re):
        """Test RAG integration with multiple knowledge sources (default prompts + user bundles)."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Create default prompts index
        default_prompts_index = {
            "chunks": [
                {
                    "content": "JavaScript is a programming language used for web development.",
                    "embedding": [0.8, 0.1, 0.1, 0.0, 0.0],
                    "metadata": {"type": "default_prompt", "promptName": "JavaScript Basics"},
                    "id": "chunk_js"
                }
            ],
            "metadata": {"totalChunks": 1}
        }
    
        # Create user bundles index
        user_bundles_index = {
            "bundles": [
                {
                    "name": "Python Guide",
                    "chunks": [
                        {
                            "content": "Python is a high-level programming language known for its simplicity.",
                            "embedding": [0.7, 0.2, 0.1, 0.0, 0.0],
                            "metadata": {"type": "user_bundle", "source": "python_guide.md"},
                            "id": "chunk_python"
                        }
                    ],
                    "files": ["python_guide.md"],
                    "metadata": {"model": "text-embedding-3-small"}
                }
            ]
        }
    
        # Store both indexes
        page.evaluate(f"localStorage.setItem('rag_default_prompts_index', '{json.dumps(default_prompts_index)}')")
        page.evaluate(f"localStorage.setItem('rag_user_bundles_index', '{json.dumps(user_bundles_index)}')")
    
        # Test multi-source search
        multi_source_result = page.evaluate("""() => {
            // Test searching for programming-related content
            // This should find results from both default prompts and user bundles
            const query = "programming language";
    
            try {
                // Search in default prompts
                const defaultResults = window.VectorRAGService.search(query, {}, 5);
    
                // Test if we can access user bundles
                const userBundles = window.RAGUserBundles.getBundles();
    
                return {
                    searchCompleted: true,
                    defaultResults: defaultResults ? defaultResults.length : 0,
                    userBundlesAvailable: userBundles ? userBundles.length : 0,
                    multiSourceSetup: defaultResults && userBundles,
                    totalSources: 2 // default prompts + user bundles
                };
            } catch (error) {
                return {
                    searchCompleted: false,
                    error: error.message
                };
            }
        }""")
    
        # Verify multi-source integration
        assert multi_source_result['searchCompleted'], "Multi-source search should complete"
>       assert multi_source_result['defaultResults'] > 0, "Should find results in default prompts"
E       TypeError: '>' not supported between instances of 'NoneType' and 'int'

test_rag_integration.py:613: TypeError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
____________________ test_rag_search_ui_elements[chromium1] ____________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_search_ui_elements(page: Page, serve_hacka_re):
        """Test the RAG search UI elements and basic functionality."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Check search section elements
        search_input = page.locator("#rag-search-input")
        expect(search_input).to_be_visible()
        expect(search_input).to_be_enabled()
    
        search_button = page.locator("#rag-search-btn")
        expect(search_button).to_be_visible()
>       expect(search_button).to_be_enabled()
E       AssertionError: Locator expected to be enabled
E       Actual value: disabled 
E       Call log:
E         - LocatorAssertions.to_be_enabled with timeout 5000ms
E         - waiting for locator("#rag-search-btn")
E           9 √ó locator resolved to <button disabled type="button" id="rag-search-btn" class="btn primary-btn" title="Enter a search query">‚Üµ                                Search‚Üµ         ‚Ä¶</button>
E             - unexpected value "disabled"

test_rag_search.py:28: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
___________________ test_rag_search_without_index[chromium1] ___________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_search_without_index(page: Page, serve_hacka_re):
        """Test search behavior when no index is available."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Clear any existing RAG index
        page.evaluate("localStorage.removeItem('rag_default_prompts_index')")
        page.evaluate("localStorage.removeItem('rag_user_bundles_index')")
    
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Try to perform a search
        search_input = page.locator("#rag-search-input")
        search_button = page.locator("#rag-search-btn")
    
        search_input.fill("test query")
        search_button.click()
    
        # Should show message about no index
>       page.wait_for_selector("#rag-search-results:has-text('No knowledge')", timeout=5000)

test_rag_search.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:8187: in wait_for_selector
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_page.py:425: in wait_for_selector
    return await self._main_frame.wait_for_selector(**locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:323: in wait_for_selector
    await self._channel.send("waitForSelector", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x103fe0180>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.wait_for_selector: Timeout 5000ms exceeded.
E           Call log:
E             - waiting for locator("#rag-search-results:has-text('No knowledge')") to be visible

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
__________________ test_rag_search_with_mock_data[chromium1] ___________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_search_with_mock_data(page: Page, serve_hacka_re):
        """Test search functionality with mock indexed data."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Create mock index data in localStorage
        mock_index = {
            "chunks": [
                {
                    "content": "Machine learning is a subset of artificial intelligence that focuses on algorithms.",
                    "embedding": [0.1, 0.2, 0.3, 0.4, 0.5],
                    "metadata": {
                        "promptId": "ml_basics",
                        "promptName": "Machine Learning Basics",
                        "type": "default_prompt"
                    },
                    "id": "chunk_0"
                },
                {
                    "content": "Deep learning uses neural networks with multiple layers to process data.",
                    "embedding": [0.2, 0.3, 0.4, 0.5, 0.6],
                    "metadata": {
                        "promptId": "deep_learning",
                        "promptName": "Deep Learning Introduction",
                        "type": "default_prompt"
                    },
                    "id": "chunk_1"
                }
            ],
            "metadata": {
                "totalChunks": 2,
                "embeddingModel": "text-embedding-3-small",
                "createdAt": "2024-01-01T00:00:00.000Z"
            }
        }
    
        # Store mock index
        page.evaluate(f"localStorage.setItem('rag_default_prompts_index', '{json.dumps(mock_index)}')")
    
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Perform a search
        search_input = page.locator("#rag-search-input")
        search_button = page.locator("#rag-search-btn")
    
        search_input.fill("machine learning")
        search_button.click()
    
        # Wait for results
>       page.wait_for_selector("#rag-search-results .rag-search-result", timeout=5000)

test_rag_search.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:8187: in wait_for_selector
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_page.py:425: in wait_for_selector
    return await self._main_frame.wait_for_selector(**locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:323: in wait_for_selector
    await self._channel.send("waitForSelector", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x104a53560>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.wait_for_selector: Timeout 5000ms exceeded.
E           Call log:
E             - waiting for locator("#rag-search-results .rag-search-result") to be visible

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
______________ test_rag_search_enter_key_functionality[chromium1] ______________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_search_enter_key_functionality(page: Page, serve_hacka_re):
        """Test search using Enter key in the search input."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Create minimal mock index for testing
        mock_index = {
            "chunks": [
                {
                    "content": "Test content for enter key search functionality.",
                    "embedding": [0.1, 0.2, 0.3, 0.4, 0.5],
                    "metadata": {"promptName": "Test Prompt"},
                    "id": "chunk_test"
                }
            ],
            "metadata": {"totalChunks": 1}
        }
    
        page.evaluate(f"localStorage.setItem('rag_default_prompts_index', '{json.dumps(mock_index)}')")
    
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Enter search query and press Enter
        search_input = page.locator("#rag-search-input")
        search_input.fill("test")
        search_input.press("Enter")
    
        # Wait for results
>       page.wait_for_selector("#rag-search-results .rag-search-result", timeout=5000)

test_rag_search.py:312: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:8187: in wait_for_selector
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_page.py:425: in wait_for_selector
    return await self._main_frame.wait_for_selector(**locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:323: in wait_for_selector
    await self._channel.send("waitForSelector", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x1040eb420>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.wait_for_selector: Timeout 5000ms exceeded.
E           Call log:
E             - waiting for locator("#rag-search-results .rag-search-result") to be visible

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_______________ test_rag_search_empty_query_handling[chromium1] ________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_search_empty_query_handling(page: Page, serve_hacka_re):
        """Test search behavior with empty or whitespace queries."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        search_input = page.locator("#rag-search-input")
        search_button = page.locator("#rag-search-btn")
        results_container = page.locator("#rag-search-results")
    
        # Test empty query
        search_input.fill("")
>       search_button.click()

test_rag_search.py:346: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:15512: in click
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_locator.py:160: in click
    return await self._frame.click(self._selector, strict=True, **params)
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:488: in click
    await self._channel.send("click", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x104a15260>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Locator.click: Timeout 10000ms exceeded.
E           Call log:
E             - waiting for locator("#rag-search-btn")
E               - locator resolved to <button disabled type="button" id="rag-search-btn" class="btn primary-btn" title="Enter a search query">‚Üµ                                Search‚Üµ         ‚Ä¶</button>
E             - attempting click action
E               2 √ó waiting for element to be visible, enabled and stable
E                 - element is not stable
E               - retrying click action
E               - waiting 20ms
E               2 √ó waiting for element to be visible, enabled and stable
E                 - element is not stable
E               - retrying click action
E                 - waiting 100ms
E               19 √ó waiting for element to be visible, enabled and stable
E                  - element is not enabled
E                - retrying click action
E                  - waiting 500ms

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_________________ test_rag_search_result_formatting[chromium1] _________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'

    def test_rag_search_result_formatting(page: Page, serve_hacka_re):
        """Test the formatting and display of search results."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
        # Create detailed mock index for result formatting test
        mock_index = {
            "chunks": [
                {
                    "content": "This is a comprehensive guide to machine learning algorithms and their applications in modern data science. It covers supervised learning, unsupervised learning, and reinforcement learning techniques.",
                    "embedding": [0.8, 0.2, 0.1, 0.1, 0.1],
                    "metadata": {
                        "promptId": "ml_guide",
                        "promptName": "Complete Machine Learning Guide",
                        "type": "default_prompt",
                        "chunkIndex": 0
                    },
                    "id": "chunk_detailed"
                }
            ],
            "metadata": {"totalChunks": 1}
        }
    
        page.evaluate(f"localStorage.setItem('rag_default_prompts_index', '{json.dumps(mock_index)}')")
    
        # Open the RAG modal
        rag_button = page.locator("#rag-btn")
        rag_button.click()
    
        # Wait for modal to become visible
        page.wait_for_selector("#rag-modal", state="visible", timeout=3000)
    
        # Perform search
        search_input = page.locator("#rag-search-input")
        search_input.fill("machine learning")
        search_input.press("Enter")
    
        # Wait for results
>       page.wait_for_selector("#rag-search-results .rag-search-result", timeout=5000)

test_rag_search.py:413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/playwright/sync_api/_generated.py:8187: in wait_for_selector
    self._sync(
.venv/lib/python3.13/site-packages/playwright/_impl/_page.py:425: in wait_for_selector
    return await self._main_frame.wait_for_selector(**locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_frame.py:323: in wait_for_selector
    await self._channel.send("waitForSelector", locals_to_params(locals()))
.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Connection object at 0x10394f8c0>
cb = <function Channel.send.<locals>.<lambda> at 0x104a53f60>
is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -> Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
>           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.wait_for_selector: Timeout 5000ms exceeded.
E           Call log:
E             - waiting for locator("#rag-search-results .rag-search-result") to be visible

.venv/lib/python3.13/site-packages/playwright/_impl/_connection.py:528: TimeoutError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
_______________ test_rag_search_with_real_embeddings[chromium1] ________________

page = <Page url='http://localhost:8000/'>
serve_hacka_re = 'http://localhost:8000'
api_key = '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'

    def test_rag_search_with_real_embeddings(page: Page, serve_hacka_re, api_key):
        """Test that RAG search works with real pre-cached embeddings and API key for query."""
        # Navigate to the application
        page.goto(serve_hacka_re)
    
        # Dismiss welcome modal if present
        dismiss_welcome_modal(page)
    
        # Configure API key for query embedding generation
        page.evaluate(f"localStorage.setItem('openai_api_key', '{api_key}')")
        page.evaluate("localStorage.setItem('base_url', 'https://api.openai.com/v1')")
        page.evaluate("localStorage.setItem('selected_model', 'gpt-4o-mini')")
    
        # Wait for initialization
        page.wait_for_timeout(2000)
    
        # Verify pre-cached embeddings are loaded
        embeddings_info = page.evaluate("""() => {
            const stats = {
                hasVectorStore: !!window.ragVectorStore,
                hasVectorService: !!window.VectorRAGService,
                documentCount: 0,
                totalVectors: 0,
                documents: []
            };
    
            if (window.ragVectorStore) {
                const docIds = window.ragVectorStore.getDocumentIds();
                stats.documentCount = docIds.length;
    
                docIds.forEach(id => {
                    const vectors = window.ragVectorStore.getVectors(id);
                    if (vectors) {
                        stats.totalVectors += vectors.length;
                        stats.documents.push({
                            id: id,
                            vectorCount: vectors.length,
                            hasEmbeddings: vectors.length > 0 && vectors[0].embedding && vectors[0].embedding.length > 0,
                            embeddingDims: vectors[0].embedding ? vectors[0].embedding.length : 0
                        });
                    }
                });
            }
    
            return stats;
        }""")
    
        print(f"Pre-cached embeddings info: {embeddings_info}")
>       assert embeddings_info['totalVectors'] == 150, f"Expected 150 vectors, got {embeddings_info['totalVectors']}"
E       AssertionError: Expected 150 vectors, got 590
E       assert 590 == 150

test_rag_with_precached.py:59: AssertionError
----------------------------- Captured stdout call -----------------------------
welcome-modal is visible, closing it
Found close button with selector: #close-welcome-modal
Clicked close button
Modal closed successfully
Pre-cached embeddings info: {'hasVectorStore': True, 'hasVectorService': True, 'documentCount': 3, 'totalVectors': 590, 'documents': [{'id': 'aia', 'vectorCount': 154, 'hasEmbeddings': True, 'embeddingDims': 1536}, {'id': 'cra', 'vectorCount': 232, 'hasEmbeddings': True, 'embeddingDims': 1536}, {'id': 'dora', 'vectorCount': 204, 'hasEmbeddings': True, 'embeddingDims': 1536}]}
--------------------------- Captured stdout teardown ---------------------------
HTTP server process already terminated
=============================== warnings summary ===============================
test_complete_mcp_share_flow.py:8
  /Users/user/dev/hacka.re/_tests/playwright/test_complete_mcp_share_flow.py:8: PytestUnknownMarkWarning: Unknown pytest.mark.feature_test - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.feature_test

test_cross_tab_loop_fix.py:8
  /Users/user/dev/hacka.re/_tests/playwright/test_cross_tab_loop_fix.py:8: PytestUnknownMarkWarning: Unknown pytest.mark.feature_test - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.feature_test

test_cross_tab_sync_optimization.py:7
  /Users/user/dev/hacka.re/_tests/playwright/test_cross_tab_sync_optimization.py:7: PytestUnknownMarkWarning: Unknown pytest.mark.feature_test - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.feature_test

test_cross_tab_sync_optimization.py:59
  /Users/user/dev/hacka.re/_tests/playwright/test_cross_tab_sync_optimization.py:59: PytestUnknownMarkWarning: Unknown pytest.mark.feature_test - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.feature_test

test_debug_utils.py:25
  /Users/user/dev/hacka.re/_tests/playwright/test_debug_utils.py:25: PytestCollectionWarning: cannot collect test class 'TestDebugger' because it has a __init__ constructor (from: test_debug_utils.py)
    class TestDebugger:

test_debug_utils.py:25
  /Users/user/dev/hacka.re/_tests/playwright/test_debug_utils.py:25: PytestCollectionWarning: cannot collect test class 'TestDebugger' because it has a __init__ constructor (from: test_example_with_debugging.py)
    class TestDebugger:

test_rag_multi_query.py:104
  /Users/user/dev/hacka.re/_tests/playwright/test_rag_multi_query.py:104: PytestUnknownMarkWarning: Unknown pytest.mark.asyncio - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.asyncio

test_rag_multi_query.py:375
  /Users/user/dev/hacka.re/_tests/playwright/test_rag_multi_query.py:375: PytestUnknownMarkWarning: Unknown pytest.mark.asyncio - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.asyncio

test_rag_similarity_scores.py:14
  /Users/user/dev/hacka.re/_tests/playwright/test_rag_similarity_scores.py:14: PytestUnknownMarkWarning: Unknown pytest.mark.asyncio - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.asyncio

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED test_context_window_scaling.py::test_context_window_scaling[chromium0]
FAILED test_debug_mode.py::test_debug_mode_checkbox_exists[chromium0] - Asser...
FAILED test_default_prompts.py::test_default_prompts_content[chromium0] - Ass...
FAILED test_default_prompts.py::test_default_prompts_selection[chromium0] - A...
FAILED test_function_group_colors.py::test_function_collection_colors[chromium0]
FAILED test_function_icons.py::test_function_calling_icons[chromium0] - Impor...
FAILED test_function_icons.py::test_multiple_function_calls_colors[chromium0]
FAILED test_function_library_multi.py::test_function_library_multi[chromium0]
FAILED test_function_library_sharing.py::test_function_library_sharing[chromium0]
FAILED test_function_parsing_logic.py::test_all_functions_callable_by_default[chromium0]
FAILED test_function_parsing_logic.py::test_only_tagged_functions_callable[chromium0]
FAILED test_function_parsing_logic.py::test_tool_tag_works[chromium0] - Impor...
FAILED test_function_parsing_logic.py::test_single_line_comment_tags[chromium0]
FAILED test_function_parsing_logic.py::test_mixed_tag_types[chromium0] - Impo...
FAILED test_input_field_scroll.py::test_input_field_scroll_behavior[chromium0]
FAILED test_input_field_scroll.py::test_input_field_scroll_safari_emulation[chromium0]
FAILED test_logo_tooltip.py::test_heart_logo_tooltip[chromium0] - AssertionEr...
FAILED test_model_selection_o4_mini.py::test_o4_mini_context_window_display[chromium0]
FAILED test_models_context_simple.py::test_context_window_display[chromium0]
FAILED test_prompt_order_and_function_library_prompt.py::test_function_library_default_prompt[chromium0]
FAILED test_rag_bundles.py::test_rag_user_bundles_ui_elements[chromium0] - As...
FAILED test_rag_bundles.py::test_rag_bundle_load_button_interaction[chromium0]
FAILED test_rag_indexing.py::test_rag_embedding_generation_ui[chromium0] - As...
FAILED test_rag_indexing.py::test_rag_embedding_generation_process[chromium0]
FAILED test_rag_indexing.py::test_rag_embedding_generation_without_api_key[chromium0]
FAILED test_rag_integration.py::test_rag_enhanced_chat_response[chromium0] - ...
FAILED test_rag_integration.py::test_rag_context_injection_mechanism[chromium0]
FAILED test_rag_integration.py::test_rag_end_to_end_workflow[chromium0] - pla...
FAILED test_rag_integration.py::test_rag_multiple_source_integration[chromium0]
FAILED test_rag_search.py::test_rag_search_ui_elements[chromium0] - Assertion...
FAILED test_rag_search.py::test_rag_search_without_index[chromium0] - playwri...
FAILED test_rag_search.py::test_rag_search_with_mock_data[chromium0] - playwr...
FAILED test_rag_search.py::test_rag_search_enter_key_functionality[chromium0]
FAILED test_rag_search.py::test_rag_search_empty_query_handling[chromium0] - ...
FAILED test_rag_search.py::test_rag_search_result_formatting[chromium0] - pla...
FAILED test_rag_with_precached.py::test_rag_search_with_real_embeddings[chromium0]
FAILED test_context_window_scaling.py::test_context_window_scaling[chromium1]
FAILED test_debug_mode.py::test_debug_mode_checkbox_exists[chromium1] - Asser...
FAILED test_default_prompts.py::test_default_prompts_content[chromium1] - Ass...
FAILED test_default_prompts.py::test_default_prompts_selection[chromium1] - A...
FAILED test_function_group_colors.py::test_function_collection_colors[chromium1]
FAILED test_function_icons.py::test_function_calling_icons[chromium1] - Impor...
FAILED test_function_icons.py::test_multiple_function_calls_colors[chromium1]
FAILED test_function_library_multi.py::test_function_library_multi[chromium1]
FAILED test_function_library_sharing.py::test_function_library_sharing[chromium1]
FAILED test_function_parsing_logic.py::test_all_functions_callable_by_default[chromium1]
FAILED test_function_parsing_logic.py::test_only_tagged_functions_callable[chromium1]
FAILED test_function_parsing_logic.py::test_tool_tag_works[chromium1] - Impor...
FAILED test_function_parsing_logic.py::test_single_line_comment_tags[chromium1]
FAILED test_function_parsing_logic.py::test_mixed_tag_types[chromium1] - Impo...
FAILED test_input_field_scroll.py::test_input_field_scroll_behavior[chromium1]
FAILED test_input_field_scroll.py::test_input_field_scroll_safari_emulation[chromium1]
FAILED test_logo_tooltip.py::test_heart_logo_tooltip[chromium1] - AssertionEr...
FAILED test_models_context_simple.py::test_context_window_display[chromium1]
FAILED test_prompt_order_and_function_library_prompt.py::test_function_library_default_prompt[chromium1]
FAILED test_rag_bundles.py::test_rag_user_bundles_ui_elements[chromium1] - As...
FAILED test_rag_bundles.py::test_rag_bundle_load_button_interaction[chromium1]
FAILED test_rag_indexing.py::test_rag_embedding_generation_ui[chromium1] - As...
FAILED test_rag_indexing.py::test_rag_embedding_generation_process[chromium1]
FAILED test_rag_indexing.py::test_rag_embedding_generation_without_api_key[chromium1]
FAILED test_rag_integration.py::test_rag_enhanced_chat_response[chromium1] - ...
FAILED test_rag_integration.py::test_rag_context_injection_mechanism[chromium1]
FAILED test_rag_integration.py::test_rag_end_to_end_workflow[chromium1] - pla...
FAILED test_rag_integration.py::test_rag_multiple_source_integration[chromium1]
FAILED test_rag_search.py::test_rag_search_ui_elements[chromium1] - Assertion...
FAILED test_rag_search.py::test_rag_search_without_index[chromium1] - playwri...
FAILED test_rag_search.py::test_rag_search_with_mock_data[chromium1] - playwr...
FAILED test_rag_search.py::test_rag_search_enter_key_functionality[chromium1]
FAILED test_rag_search.py::test_rag_search_empty_query_handling[chromium1] - ...
FAILED test_rag_search.py::test_rag_search_result_formatting[chromium1] - pla...
FAILED test_rag_with_precached.py::test_rag_search_with_real_embeddings[chromium1]
= 71 failed, 115 passed, 6 skipped, 726 deselected, 9 warnings in 1447.10s (0:24:07) =
Generating test results markdown files...
No arguments provided. Using default files.
Processing default files...
Generating markdown report for 'test_output.log' -> 'test_results.md'...
Markdown report generated: test_results.md
You can view it with: glow -p test_results.md
Warning: Output file 'run_tests.out_bundle.md' is newer than input file 'run_tests.out'.
This suggests the bundle has already been generated for this test run.
To regenerate, delete 'run_tests.out_bundle.md' first.

All feature test output, including any Ctrl+C interruptions, has been captured to run_feature_tests.out
A bundled markdown report has been generated at run_tests.out_bundle.md
You can view the markdown report with: glow -p run_tests.out_bundle.md
These files can be used by the coding assistant LLM to analyze test results
Stopping HTTP server...
===== Stopping HTTP Server for hacka.re Tests =====
Found server process with PID: 28587
Stopping server...
Server stopped.
Removed PID file: /Users/user/dev/hacka.re/_tests/playwright/server_pid.txt
==================================================
Server stopped.
