<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Function Tag Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 0;
        }
        #result {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>
    <h1>Function Tag Test</h1>
    <p>This page tests the function tagging logic to ensure only tagged functions are marked as callable.</p>
    
    <h2>Test Case 1: Only Second Function Tagged</h2>
    <pre id="test1">
function quantum_solve(query) { return 2238238238238283283 }
// @tool
function quantum_deep(query) { return 384783743 }
    </pre>
    <button onclick="testFunctionTagging('test1')">Test Case 1</button>
    
    <h2>Test Case 2: Only First Function Tagged</h2>
    <pre id="test2">
// @tool
function quantum_solve(query) { return 2238238238238283283 }

function quantum_deep(query) { return 384783743 }
    </pre>
    <button onclick="testFunctionTagging('test2')">Test Case 2</button>
    
    <h2>Test Case 3: No Functions Tagged</h2>
    <pre id="test3">
function quantum_solve(query) { return 2238238238238283283 }

function quantum_deep(query) { return 384783743 }
    </pre>
    <button onclick="testFunctionTagging('test3')">Test Case 3</button>
    
    <h2>Test Case 4: Both Functions Tagged</h2>
    <pre id="test4">
// @tool
function quantum_solve(query) { return 2238238238238283283 }
// @tool
function quantum_deep(query) { return 384783743 }
    </pre>
    <button onclick="testFunctionTagging('test4')">Test Case 4</button>
    
    <h2>Test Case 5: One Function Internal</h2>
    <pre id="test5">
// @internal
function quantum_solve(query) { return 2238238238238283283 }

function quantum_deep(query) { return 384783743 }
    </pre>
    <button onclick="testFunctionTagging('test5')">Test Case 5</button>
    
    <h2>Test Case 6: Both Functions Internal</h2>
    <pre id="test6">
// @internal
function quantum_solve(query) { return 2238238238238283283 }
// @internal
function quantum_deep(query) { return 384783743 }
    </pre>
    <button onclick="testFunctionTagging('test6')">Test Case 6</button>
    
    <h2>Test Case 7: Mixed Internal and Tool</h2>
    <pre id="test7">
// @internal
function quantum_solve(query) { return 2238238238238283283 }
// @tool
function quantum_deep(query) { return 384783743 }
    </pre>
    <button onclick="testFunctionTagging('test7')">Test Case 7</button>
    
    <div id="result"></div>
    
    <script>
        // Mock the extractFunctions function from function-calling-manager.js
        function extractFunctions(code) {
            if (!code) return [];
            
            try {
                // Normalize indentation
                const normalizedCode = code.replace(/^[ \t]+/gm, '');
                
                // Find all function declarations in the code
                // This regex captures the JSDoc comment (if any), any single-line comment before the function, and the function declaration
                const functionRegex = /(\/\*\*[\s\S]*?\*\/\s*)?(\/\/.*?\n\s*)?(?:async\s+)?function\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\(([^)]*)\)[\s\S]*?(?=\/\*\*[\s\S]*?function|\s*function\s+[a-zA-Z_$]|\s*$)/g;
                
                const functions = [];
                let match;
                
                while ((match = functionRegex.exec(normalizedCode)) !== null) {
                    const jsDoc = match[1] || '';
                    const singleLineComment = match[2] || '';
                    const functionName = match[3];
                    const params = match[4];
                    
                    // Get the full function code by finding the opening brace and matching closing brace
                    const functionStartIndex = match.index + (jsDoc ? jsDoc.length : 0);
                    const functionDeclaration = normalizedCode.substring(functionStartIndex);
                    
                    // Find the function body by matching braces
                    let braceCount = 0;
                    let endIndex = 0;
                    let foundOpeningBrace = false;
                    
                    for (let i = 0; i < functionDeclaration.length; i++) {
                        const char = functionDeclaration[i];
                        
                        if (char === '{') {
                            foundOpeningBrace = true;
                            braceCount++;
                        } else if (char === '}') {
                            braceCount--;
                            
                            if (foundOpeningBrace && braceCount === 0) {
                                endIndex = i + 1;
                                break;
                            }
                        }
                    }
                    
                    // Extract the full function code including JSDoc
                    const fullFunctionCode = (jsDoc || '') + functionDeclaration.substring(0, endIndex);
                    
                    // Check if the function is marked as callable with any of the supported markers
                    // in JSDoc comments: @callable_function, @callable, @tool
                    const hasCallableMarker = jsDoc && (
                        jsDoc.includes('@callable_function') || 
                        jsDoc.includes('@callable') || 
                        jsDoc.includes('@tool')
                    );
                    
                    // Check for single-line comments with @callable or @tool
                    // This will match both "// @callable" and "// @tool"
                    const hasSingleLineCommentMarker = singleLineComment && 
                        (singleLineComment.includes('@callable') || singleLineComment.includes('@tool'));
                    
                    // Check if the function is marked as internal
                    const hasInternalMarker = (jsDoc && jsDoc.includes('@internal')) || 
                        (singleLineComment && singleLineComment.includes('@internal'));
                    
                    // Mark as callable if it has any of the markers
                    // If it has a callable/tool marker, that takes precedence over @internal
                    const isCallable = hasCallableMarker || hasSingleLineCommentMarker;
                    
                    functions.push({
                        name: functionName,
                        code: fullFunctionCode,
                        isCallable: isCallable,
                        isInternal: hasInternalMarker
                    });
                }
                
                // Check if any function has a callable marker
                const hasAnyCallableMarker = functions.some(func => {
                    // Check if this function has a callable marker
                    const functionCode = func.code;
                    const jsDoc = functionCode.match(/\/\*\*[\s\S]*?\*\//)?.[0] || '';
                    const singleLineComment = functionCode.match(/\/\/.*?\n/)?.[0] || '';
                    
                    const hasCallableMarker = jsDoc && (
                        jsDoc.includes('@callable_function') || 
                        jsDoc.includes('@callable') || 
                        jsDoc.includes('@tool')
                    );
                    
                    const hasSingleLineCommentMarker = singleLineComment && 
                        (singleLineComment.includes('@callable') || singleLineComment.includes('@tool'));
                    
                    return hasCallableMarker || hasSingleLineCommentMarker;
                });
                
                // Check if any function has an internal marker
                const hasAnyInternalMarker = functions.some(func => func.isInternal);
                
                // If no function has a callable marker:
                if (!hasAnyCallableMarker && functions.length > 0) {
                    // If there are any @internal markers, mark all functions as callable EXCEPT those marked as @internal
                    if (hasAnyInternalMarker) {
                        functions.forEach(func => {
                            func.isCallable = !func.isInternal;
                        });
                    } else {
                        // If no @internal markers either, mark all as callable (original behavior)
                        functions.forEach(func => {
                            func.isCallable = true;
                        });
                    }
                }
                // If at least one function has a callable marker, only those explicitly marked remain callable
                // (the @internal tag has no effect in this case as it's already the default for non-tagged functions)
                
                return functions;
            } catch (error) {
                console.error('Error extracting functions:', error);
                return [];
            }
        }
        
        function testFunctionTagging(testId) {
            const code = document.getElementById(testId).textContent.trim();
            console.log('Original code:', code);
            
            // Normalize indentation
            const normalizedCode = code.replace(/^[ \t]+/gm, '');
            console.log('Normalized code:', normalizedCode);
            
            // Find all function declarations in the code
            const functionRegex = /(\/\*\*[\s\S]*?\*\/\s*)?(\/\/.*?\n\s*)?(?:async\s+)?function\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\(([^)]*)\)[\s\S]*?(?=\/\*\*[\s\S]*?function|\s*function\s+[a-zA-Z_$]|\s*$)/g;
            
            // Debug regex matches
            let match;
            let debugMatches = [];
            const regexForDebug = new RegExp(functionRegex);
            let tempCode = normalizedCode;
            
            while ((match = regexForDebug.exec(tempCode)) !== null) {
                debugMatches.push({
                    fullMatch: match[0],
                    jsDoc: match[1] || '',
                    singleLineComment: match[2] || '',
                    functionName: match[3],
                    params: match[4]
                });
            }
            
            console.log('Regex matches:', debugMatches);
            
            const functions = extractFunctions(code);
            
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = '<h3>Test Results:</h3>';
            
            const callableFunctions = functions.filter(func => func.isCallable);
            
            resultDiv.innerHTML += `<p>Total functions found: ${functions.length}</p>`;
            resultDiv.innerHTML += `<p>Callable functions: ${callableFunctions.length}</p>`;
            
            resultDiv.innerHTML += '<h4>Function Details:</h4>';
            functions.forEach(func => {
                // Extract the JSDoc and single-line comment for debugging
                const jsDoc = func.code.match(/\/\*\*[\s\S]*?\*\//)?.[0] || '';
                const singleLineComment = func.code.match(/\/\/.*?\n/)?.[0] || '';
                
                resultDiv.innerHTML += `
                    <p>
                        <strong>${func.name}</strong>: ${func.isCallable ? 'Callable' : 'Not Callable'}<br>
                        <small>JSDoc: ${jsDoc ? 'Yes' : 'No'}</small><br>
                        <small>Single-line comment: ${singleLineComment ? `"${singleLineComment.trim()}"` : 'No'}</small><br>
                        <small>Has @tool or @callable: ${(jsDoc && (jsDoc.includes('@tool') || jsDoc.includes('@callable'))) || 
                                                       (singleLineComment && (singleLineComment.includes('@tool') || singleLineComment.includes('@callable'))) ? 'Yes' : 'No'}</small><br>
                        <small>Is @internal: ${func.isInternal ? 'Yes' : 'No'}</small>
                    </p>
                `;
            });
            
            console.log('Test results:', functions);
        }
    </script>
</body>
</html>
